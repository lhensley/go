# Variable definitions for Lane applications

# Debug Mode
# Leave near the top so it can be toggled on and off easily.
	# Default=false
		DEBUG_MODE=false
	# Alert levels: 0=none 1=light 2=normal 3=heavy 5=everything
		#CONFIG_system_log_level
		LOG_LEVEL=2
		TEXT_LEVEL=2

# Set a flag to confirm that the variables are not yet defined
	VARIABLES_ARE_DEFINED=false

# Built-in (at command line, use env to show more)
	# HOME (Home directory)
	# HOSTNAME (this host, not FQDN)
	# SHELL
	# USER (Current user)
		RUN_AS="$USER"

# Global
	HOME_ROOT="/home"
	SBIN_DIR="/usr/local/sbin"
	SBIN_PARENT="$(dirname $SBIN_DIR)"
	DOMAIN_NAME="lanehensley.org"
	DOMAIN_LOCAL="lan"
	COLOPHON="by Lane Hensley, lane@lanehensley.org, https://lanehensley.org"

# /etc/os-release defines a lot of environment variables 
# Sample:
#    NAME="Ubuntu"
#    VERSION="18.04.4 LTS (Bionic Beaver)"
#    ID=ubuntu
#    ID_LIKE=debian
#    PRETTY_NAME="Ubuntu 18.04.4 LTS"
#    VERSION_ID="18.04"
#    HOME_URL="https://www.ubuntu.com/"
#    SUPPORT_URL="https://help.ubuntu.com/"
#    BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
#    PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
#    VERSION_CODENAME=bionic
#    UBUNTU_CODENAME=bionic
source /etc/os-release

# Basic Plex info
PLEX_INSTALLATION_PATH="/var/lib/plexmediaserver"
PLEX_LIBRARY_PATH="$PLEX_INSTALLATION_PATH/Library"
PLEX_APPLICATION_SUPPORT_PATH="$PLEX_LIBRARY_PATH/Application Support"

# Start timestamps
# Ref https://www.cyberciti.biz/faq/linux-unix-formatting-dates-for-display/ for date format %codes
	START_DATEANDTIMESTAMP=$(/bin/date '+%Y-%m-%d-%H-%M-%S-%Z')     # Like 2020-09-07-16-05-23-CDT. Used in naming SSH keys and backing up installed files like fstab
	START_DATESTAMP=$(/bin/date '+%Y-%m-%d')                        # Like 2020-09-07. Used in backup variables below
	START_DAYSTAMP=$(/bin/date '+%d')                               # Like 07
	START_MONTHSTAMP=$(/bin/date '+%Y-%m')                          # Like 2020-09
	START_TIMESTAMP=$(/bin/date)                                    # Like Mon 07 Sep 2020 04:01:23 PM CDT
	START_WEEKDAYSTAMP=$(/bin/date '+%a')                           # Like Mon. Used in backup variables below
	START_WEEKDAYSTAMP2=$(/bin/date '+%Y-%m-%d-%H-%M-%S-%Z-%a')     # Like 2020-09-07-16-05-23-CDT-Mon. Used in backup variables below
	START_WEEKDAYSTAMP3=$(/bin/date '+%w-%a')                       # Like 0-Sun, 1-Mon, 2-Tue, etc. Used in backup variables below




# Define host-specific values
	declare -A HOST
	# default
		# Name of this host
			THISHOST="default"
		# Network Addressing
			# Calculated
				# Safe local address
					HOST[$THISHOST,local]="$THISHOST.$DOMAIN_LOCAL"
				# Preferred global address; normally the ip6 address
					HOST[$THISHOST,global]="$THISHOST.$DOMAIN_NAME"
		# Work file container location; used for Plex DVR raw files and cold backup staging
		# CAUTION: Root file system will quickly fill; use large storage device.
			# Used for temporary storage and quick storage response time
				HOST[$THISHOST,work_container]="/var/local"
		# Plex Transcoding; defines transcoding only, not Plex functioning
			# App container name (default="plex")
				HOST[$THISHOST,plex_app_container]="plex"
			# Function container name (default="dvr")
				HOST[$THISHOST,plex_function_container]="dvr"
			# .ts files container name (default="in")
				HOST[$THISHOST,plex_function_ts_container]="in"
			# .mkv files container name (default="out")
				HOST[$THISHOST,plex_function_mkv_container]="out"
			# Base path where transcode scripts can find raw .ts files made by Plex DVR
				HOST[$THISHOST,video_work_container]="${HOST[$THISHOST,work_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_app_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_ts_container]}"
			# Base path for Plex DVR files transcoded to .m4v by HandBrake
				HOST[$THISHOST,video_store_container]="${HOST[$THISHOST,work_container]}"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_app_container]}"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_container]}"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_mkv_container]}"
		# Archive locations
			# DEPENDENT on timestamp definitions
			# DEPENDENT on definition of $HOSTNAME, but that's built-in
			# Archive STORAGE container parent name
				HOST[$THISHOST,archive_app_parent]="${HOST[$THISHOST,work_container]}"
			# App container name (Normally "archives")
				HOST[$THISHOST,archive_app_container]="archives"
			# Base path for temporary archive storage.
				HOST[$THISHOST,temp_archive_base_path]="${HOST[$THISHOST,archive_app_parent]}/${HOST[$THISHOST,archive_app_container]}/tmp"
			# Base path where completed archives are STORED long term. Typically this is a 5TB external drive, if there is one.
				HOST[$THISHOST,archive_base_path]="${HOST[$THISHOST,work_container]}/${HOST[$THISHOST,archive_app_container]}/$HOSTNAME"
			# Behavior of the archive storage file system: read-only, true or false
			# IMPORTANT: This does not set /etc/fstab. It only determines whether to mount and unmount manually.
				HOST[$THISHOST,archive_storage_file_system_read_only]=false
	# nuc01 #IMPORTANT: This section needs to come BEFORE adam; adam definitions point to nuc01
		# Name of this host
			THISHOST="nuc01"
		# Network Addressing
			# Calculated
				# Safe local address
					HOST[$THISHOST,local]="${HOST[$THISHOST,local]}"
				# Preferred global address; normally the ip6 address
					HOST[$THISHOST,global]="${HOST[$THISHOST,global]}"
		# Work file container location; used for Plex DVR raw files and cold backup staging
		# CAUTION: Root file system will quickly fill; use large storage device.
			# Used for temporary storage and quick storage response time
				HOST[$THISHOST,work_container]="/mnt/bob"
		# Plex Transcoding; defines transcoding only, not Plex functioning
			# App container name (default="plex")
				HOST[$THISHOST,plex_app_container]="${HOST[default,plex_app_container]}"
			# Function container name (default="dvr")
				HOST[$THISHOST,plex_function_container]="plex-dvr"
			# .ts files container name (default="in")
				HOST[$THISHOST,plex_function_ts_container]="${HOST[default,plex_function_ts_container]}"
			# .mkv files container name (default="out")
				HOST[$THISHOST,plex_function_mkv_container]="${HOST[default,plex_function_mkv_container]}"
			# Base path where transcode scripts can find raw .ts files made by Plex DVR
				HOST[$THISHOST,video_work_container]="${HOST[$THISHOST,work_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_app_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_ts_container]}"
			# Base path for Plex DVR files transcoded to .m4v by HandBrake
				HOST[$THISHOST,video_store_container]="/mnt/cloteal"
#					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_app_container]}"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_container]}"
#					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_mkv_container]}"
		# Archive locations
			# DEPENDENT on timestamp definitions
			# DEPENDENT on definition of $HOSTNAME, but that's built-in
			# Archive STORAGE container parent name
				HOST[$THISHOST,archive_app_parent]="/mnt/5TBE"
			# App container name
				HOST[$THISHOST,archive_app_container]="${HOST[default,archive_app_container]}"
			# Base path for temporary archive storage.
				HOST[$THISHOST,temp_archive_base_path]="${HOST[$THISHOST,work_container]}/${HOST[$THISHOST,archive_app_container]}/tmp"
			# Base path where completed archives are STORED long term. Typically this is a 5TB external drive, if there is one.
				HOST[$THISHOST,archive_base_path]="${HOST[$THISHOST,app_parent]}/${HOST[$THISHOST,archive_app_container]}/$HOSTNAME"
			# Behavior of the archive storage file system: read-only, true or false
			# IMPORTANT: This does not set /etc/fstab. It only determines whether to mount and unmount manually.
				HOST[$THISHOST,archive_storage_file_system_read_only]=false
	# adam #IMPORTANT: This section needs to come AFTER nuc01; adam definitions point to nuc01
		# Name of this host
			THISHOST="adam"
		# Network Addressing
			# Calculated
				# Safe local address
					HOST[$THISHOST,local]="${HOST[$THISHOST,local]}"
				# Preferred global address; normally the ip6 address
					HOST[$THISHOST,global]="${HOST[$THISHOST,global]}"
		# Work file container location; used for Plex DVR raw files and cold backup staging
		# CAUTION: Root file system will quickly fill; use large storage device.
			# Used for temporary storage and quick storage response time
				HOST[$THISHOST,work_container]="${HOST[default,work_container]}"
		# Plex Transcoding; defines transcoding only, not Plex functioning
			# App container name (default="plex")
				HOST[$THISHOST,archive_app_container]="${HOST[default,archive_app_container]}"
			# Function container name (default="dvr")
				HOST[$THISHOST,plex_function_container]="${HOST[default,plex_function_container]}"
			# .ts files container name (default="in")
				HOST[$THISHOST,plex_function_ts_container]="${HOST[default,plex_function_ts_container]}"
			# .mkv files container name (default="out")
				HOST[$THISHOST,plex_function_mkv_container]="${HOST[default,plex_function_mkv_container]}"
			# Base path where transcode scripts can find raw .ts files made by Plex DVR
				HOST[$THISHOST,video_work_container]="${HOST[nuc01,video_work_container]}"  # Temporarily pointing to nuc01
#				HOST[$THISHOST,video_work_container]="${HOST[$THISHOST,work_container]}"
#					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_app_container]}"
#					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_container]}"
#					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_ts_container]}"
			# Base path for Plex DVR files transcoded to .m4v by HandBrake
				HOST[$THISHOST,video_store_container]="${HOST[nuc01,video_store_container]}"  # Temporarily pointing to nuc01
#				HOST[$THISHOST,video_store_container]="${HOST[$THISHOST,work_container]}"
#					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_app_container]}"
#					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_container]}"
#					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_mkv_container]}"
		# Archive locations
			# DEPENDENT on timestamp definitions
			# DEPENDENT on definition of $HOSTNAME, but that's built-in
			# Archive STORAGE container parent name
				HOST[$THISHOST,archive_app_parent]="/mnt/5TBD"
			# App container name
				HOST[$THISHOST,archive_app_container]="${HOST[default,archive_app_container]}"
			# Base path for temporary archive storage.
				HOST[$THISHOST,temp_archive_base_path]="${HOST[$THISHOST,work_container]}/${HOST[$THISHOST,archive_app_container]}/tmp"
			# Base path where completed archives are STORED long term. Typically this is a 5TB external drive, if there is one.
				HOST[$THISHOST,archive_base_path]="${HOST[$THISHOST,app_parent]}/${HOST[$THISHOST,archive_app_container]}/$HOSTNAME"
			# Behavior of the archive storage file system: read-only, true or false
			# IMPORTANT: This does not set /etc/fstab. It only determines whether to mount and unmount manually.
				HOST[$THISHOST,archive_storage_file_system_read_only]=false
	# oz
		# Name of this host
			THISHOST="oz"
		# Network Addressing
			# Calculated
				# Safe local address
					HOST[$THISHOST,local]="${HOST[$THISHOST,local]}"
				# Preferred global address; normally the ip6 address
					HOST[$THISHOST,global]="${HOST[$THISHOST,global]}"
		# Work file container location; used for Plex DVR raw files and cold backup staging
		# CAUTION: Root file system will quickly fill; use large storage device.
			# Used for temporary storage and quick storage response time
				HOST[$THISHOST,work_container]="/mnt/ssd1tb"
		# Plex Transcoding; defines transcoding only, not Plex functioning
			# App container name (default="plex")
				HOST[$THISHOST,plex_app_container]="${HOST[default,plex_app_container]}"
			# Function container name (default="dvr-oz")
				HOST[$THISHOST,plex_function_container]="${HOST[default,plex_function_container]}"
			# .ts files container name (default="in")
				HOST[$THISHOST,plex_function_ts_container]="${HOST[default,plex_function_ts_container]}"
			# .mkv files container name (default="out")
				HOST[$THISHOST,plex_function_mkv_container]="${HOST[default,plex_function_mkv_container]}"
			# Base path where transcode scripts can find raw .ts files made by Plex DVR
				HOST[$THISHOST,video_work_container]="${HOST[$THISHOST,work_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_app_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_container]}"
					HOST[$THISHOST,video_work_container]+="/${HOST[$THISHOST,plex_function_ts_container]}"
			# Base path for Plex DVR files transcoded to .m4v by HandBrake
				HOST[$THISHOST,video_store_container]="/mnt/ext10tb01"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_app_container]}"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_container]}"
					HOST[$THISHOST,video_store_container]+="/${HOST[$THISHOST,plex_function_mkv_container]}"
		# Archive locations
			# DEPENDENT on timestamp definitions
			# DEPENDENT on definition of $HOSTNAME, but that's built-in
			# Archive STORAGE container parent name
				HOST[$THISHOST,archive_app_parent]="/mnt/5TBE"
			# App container name
				HOST[$THISHOST,archive_app_container]="${HOST[default,archive_app_container]}"
			# Base path for temporary archive storage.
				HOST[$THISHOST,temp_archive_base_path]="${HOST[$THISHOST,work_container]}/${HOST[$THISHOST,archive_app_container]}/tmp"
			# Base path where completed archives are STORED long term. Typically this is a 5TB external drive, if there is one.
				HOST[$THISHOST,archive_base_path]="${HOST[$THISHOST,app_parent]}/${HOST[$THISHOST,archive_app_container]}/$HOSTNAME"
			# Behavior of the archive storage file system: read-only, true or false
			# IMPORTANT: This does not set /etc/fstab. It only determines whether to mount and unmount manually.
				HOST[$THISHOST,archive_storage_file_system_read_only]=false


# Define hosts-specific variables
	declare -A IP4
		IP4[default]="$LOCALHOST4"
		IP4[adam]="a4.$DOMAIN_NAME"
		IP4[nuc01]="n4.$DOMAIN_NAME"
		IP4[oz]="o4.$DOMAIN_NAME"
		if [ -z "${IP4[$HOSTNAME]}" ]; then 
			if [ -z "$IP4[default]" ]; then unset IP4[this]; 
				else IP4[this]="${IP4[default]}"; fi; 
			else IP4[this]="${IP4[$HOSTNAME]}"; fi
		IP4="${IP4[this]}"
	declare -A IP6
		IP6[default]="$LOCALHOST6"
		IP6[adam]="a6.$DOMAIN_NAME"
		IP6[nuc01]="n6.$DOMAIN_NAME"
		IP6[oz]="o6.$DOMAIN_NAME"
		if [ -z "${IP6[$HOSTNAME]}" ]; then 
			if [ -z "$IP6[default]" ]; then unset IP6[this]; 
				else IP6[this]="${IP6[default]}"; fi; 
			else IP6[this]="${IP6[$HOSTNAME]}"; fi
		IP6="${IP6[this]}"
	declare -A NETADDR
		NETADDR[default]="${IP6[default]}"
		NETADDR[this]="${IP6[$HOSTNAME]}"
		NETADDR="${NETADDR[this]}"
	declare -A TEMP_FILE_SYSTEM
		TEMP_FILE_SYSTEM[default]="/"
		TEMP_FILE_SYSTEM[adam]="${TEMP_FILE_SYSTEM[default]}"
		TEMP_FILE_SYSTEM[nuc01]="/mnt/bob"
		TEMP_FILE_SYSTEM[oz]="/mnt/ssd1tb"
		if [ -z "${TEMP_FILE_SYSTEM[$HOSTNAME]}" ]; then 
			if [ -z "$TEMP_FILE_SYSTEM[default]" ]; then unset IP6[this]; 
				else TEMP_FILE_SYSTEM[this]="${TEMP_FILE_SYSTEM[default]}"; fi; 
			else TEMP_FILE_SYSTEM[this]="${TEMP_FILE_SYSTEM[$HOSTNAME]}"; fi
		TEMP_FILE_SYSTEM="${TEMP_FILE_SYSTEM[this]}"
	declare -A TEMP_ROOT
		TEMP_ROOT[default]="${TEMP_FILE_SYSTEM[default]}/var/tmp"
		TEMP_ROOT[adam]="${TEMP_FILE_SYSTEM[adam]}/var/tmp"
		TEMP_ROOT[nuc01]="${TEMP_FILE_SYSTEM[nuc01]}"
		TEMP_ROOT[oz]="${TEMP_FILE_SYSTEM[oz]}"
		if [ -z "${TEMP_ROOT[$HOSTNAME]}" ]; then 
			if [ -z "$TEMP_ROOT[default]" ]; then unset TEMP_ROOT[this]; 
				else TEMP_ROOT[this]="${TEMP_ROOT[default]}"; fi; 
			else TEMP_ROOT[this]="${TEMP_ROOT[$HOSTNAME]}"; fi
		TEMP_ROOT="${TEMP_ROOT[this]}"
  # Define all Plex data root directories
  # Set them all as true
  # Example: PLEX_DATA_ROOT[nuc01,/mnt/cloteal/plex]=true
  # IMPORTANT: If you leave anything out, the missing directories won't be backed up.
  # MORE IMPORTANT: I'm not sure this section still is used for anything ... 8/29/2021
	declare -A PLEX_DATA_ROOT
		PLEX_DATA_ROOT[adam,/mnt/cloteal/plex]=true
		PLEX_DATA_ROOT[adam,/mnt/cloteal/plex-dvr]=true
		PLEX_DATA_ROOT[adam,/mnt/bertha/plex]=true
		PLEX_DATA_ROOT[adam,/mnt/bob/plex]=true
		PLEX_DATA_ROOT[nuc01,/mnt/cloteal/plex]=true
		PLEX_DATA_ROOT[nuc01,/mnt/cloteal/plex-dvr]=true
		PLEX_DATA_ROOT[nuc01,/mnt/bertha/plex]=true
		PLEX_DATA_ROOT[nuc01,/mnt/bob/plex]=true
		PLEX_DATA_ROOT[nuc01,/var/lib/plexmediaserver/Library/metadata]=true	
		PLEX_DATA_ROOT[nuc01,/var/lib/plexmediaserver/Library/store]=true	
		PLEX_DATA_ROOT[nuc01,/var/lib/plexmediaserver/Library/work]=true	
		PLEX_DATA_ROOT[oz,/var/lib/plexmediaserver/Library/metadata]=true	
		PLEX_DATA_ROOT[oz,/var/lib/plexmediaserver/Library/store]=true	
		PLEX_DATA_ROOT[oz,/var/lib/plexmediaserver/Library/work]=true	
		PLEX_DATA_ROOT[oz,/mnt/ssd1tb/plex]=true
		PLEX_DATA_ROOT[oz,/mnt/ext10tb01/plex]=true
		for idx in "${!PLEX_DATA_ROOT[@]}"; do
			IFS=',' read -r HOSTX PATHX <<< "$idx"
			if [ "$HOSTX"=="$HOSTNAME" ]; then PLEX_DATA_ROOT[this,$PATHX]=true; fi
			done
	declare -A VIDEO_WORK_FILE_SYSTEM
		VIDEO_WORK_FILE_SYSTEM[default]="/"
		VIDEO_WORK_FILE_SYSTEM[adam]="${TEMP_FILE_SYSTEM[nuc01]}"
		VIDEO_WORK_FILE_SYSTEM[nuc01]="${TEMP_FILE_SYSTEM[nuc01]}"
		VIDEO_WORK_FILE_SYSTEM[oz]="${TEMP_FILE_SYSTEM[oz]}"
		if [ -z "${VIDEO_WORK_FILE_SYSTEM[$HOSTNAME]}" ]; then 
			if [ -z "${VIDEO_WORK_FILE_SYSTEM[default]}" ]; then unset VIDEO_WORK_FILE_SYSTEM[this]; 
				else VIDEO_WORK_FILE_SYSTEM[this]="${VIDEO_WORK_FILE_SYSTEM[default]}"; fi; 
			else VIDEO_WORK_FILE_SYSTEM[this]="${VIDEO_WORK_FILE_SYSTEM[$HOSTNAME]}"; fi
		VIDEO_WORK_FILE_SYSTEM="${VIDEO_WORK_FILE_SYSTEM[this]}"
	declare -A VIDEO_WORK_DIRECTORY
		VIDEO_WORK_DIRECTORY[default]="/"
		VIDEO_WORK_DIRECTORY[adam]="${VIDEO_WORK_FILE_SYSTEM[adam]}/plex/dvr/in"
		VIDEO_WORK_DIRECTORY[nuc01]="${VIDEO_WORK_FILE_SYSTEM[nuc01]}/plex/dvr-oz"
		VIDEO_WORK_DIRECTORY[oz]="${VIDEO_WORK_FILE_SYSTEM[oz]}/plex/dvr/in"
		if [ -z "${VIDEO_WORK_DIRECTORY[$HOSTNAME]}" ]; then 
			if [ -z "$VIDEO_WORK_DIRECTORY[default]" ]; then unset VIDEO_WORK_DIRECTORY[this]; 
				else VIDEO_WORK_DIRECTORY[this]="${VIDEO_WORK_DIRECTORY[default]}"; fi; 
			else VIDEO_WORK_DIRECTORY[this]="${VIDEO_WORK_DIRECTORY[$HOSTNAME]}"; fi
		VIDEO_WORK_DIRECORY="${VIDEO_WORK_DIRECTORY[this]}"
	declare -A VIDEO_STORE_FILE_SYSTEM
		VIDEO_STORE_FILE_SYSTEM[default]="/"
		VIDEO_STORE_FILE_SYSTEM[adam]="/mnt/cloteal"
		VIDEO_STORE_FILE_SYSTEM[nuc01]="/mnt/cloteal"
		VIDEO_STORE_FILE_SYSTEM[oz]="/mnt/ext10tb01"
		if [ -z "${VIDEO_STORE_FILE_SYSTEM[$HOSTNAME]}" ]; then 
			if [ -z "{$VIDEO_STORE_FILE_SYSTEM[default]}" ]; then unset VIDEO_STORE_FILE_SYSTEM[this]; 
				else VIDEO_STORE_FILE_SYSTEM[this]="${VIDEO_STORE_FILE_SYSTEM[default]}"; fi; 
			else VIDEO_STORE_FILE_SYSTEM[this]="${VIDEO_STORE_FILE_SYSTEM[$HOSTNAME]}"; fi
		VIDEO_STORE_FILE_SYSTEM="${VIDEO_STORE_FILE_SYSTEM[this]}"
	declare -A VIDEO_STORE_DIRECTORY
		VIDEO_STORE_DIRECTORY[default]="/"
		VIDEO_STORE_DIRECTORY[adam]="${VIDEO_STORE_FILE_SYSTEM[nuc01]}/plex-dvr"
		VIDEO_STORE_DIRECTORY[nuc01]="${VIDEO_STORE_FILE_SYSTEM[nuc01]}/plex-dvr"
		VIDEO_STORE_DIRECTORY[oz]="${VIDEO_STORE_FILE_SYSTEM[oz]}/plex/dvr-oz"
		if [ -z "${VIDEO_STORE_DIRECTORY[$HOSTNAME]}" ]; then 
			if [ -z "$VIDEO_STORE_DIRECTORY[default]" ]; then unset VIDEO_STORE_DIRECTORY[this]; 
				else VIDEO_STORE_DIRECTORY[this]="${VIDEO_STORE_DIRECTORY[default]}"; fi; 
			else VIDEO_STORE_DIRECTORY[this]="${VIDEO_STORE_DIRECTORY[$HOSTNAME]}"; fi
		VIDEO_STORE_DIRECTORY="${VIDEO_STORE_DIRECTORY[this]}"

  # Archive Directories, Files, and Paths
  # DEPENDENT on timestamp definitions
  # DEPENDENT on definition of $HOSTNAME, but that's built-in
	declare -A ARCHIVE_FILE_SYSTEM
		ARCHIVE_FILE_SYSTEM[default]="/"
		ARCHIVE_FILE_SYSTEM[adam]="/mnt/3TBD"
		ARCHIVE_FILE_SYSTEM[nuc01]="/mnt/5TBE"
		ARCHIVE_FILE_SYSTEM[oz]="/mnt/5TBC"
		if [ -z "${ARCHIVE_FILE_SYSTEM[$HOSTNAME]}" ]; then 
			if [ -z "$ARCHIVE_FILE_SYSTEM[default]" ]; then unset ARCHIVE_FILE_SYSTEM[this]; 
				else ARCHIVE_FILE_SYSTEM[this]="${ARCHIVE_FILE_SYSTEM[default]}"; fi; 
			else ARCHIVE_FILE_SYSTEM[this]="${ARCHIVE_FILE_SYSTEM[$HOSTNAME]}"; fi
		ARCHIVE_FILE_SYSTEM="${ARCHIVE_FILE_SYSTEM[this]}"
	declare -A ARCHIVE_DIRECTORY
		ARCHIVE_DIRECTORY[default]="/var/lib/archives/$HOSTNAME"
		ARCHIVE_DIRECTORY[adam]="${ARCHIVE_FILE_SYSTEM[adam]}/archives/adam"
		ARCHIVE_DIRECTORY[nuc01]="${ARCHIVE_FILE_SYSTEM[nuc01]}/archives/nuc01"
		ARCHIVE_DIRECTORY[oz]="${ARCHIVE_FILE_SYSTEM[oz]}/archives/oz"
		if [ -z "${ARCHIVE_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$ARCHIVE_DIRECTORY[default]" ]; then unset ARCHIVE_DIRECTORY[this];
				else ARCHIVE_DIRECTORY[this]="${ARCHIVE_DIRECTORY[default]}"; fi;
			else ARCHIVE_DIRECTORY[this]="${ARCHIVE_DIRECTORY[$HOSTNAME]}"; fi
		ARCHIVE_DIRECTORY="${ARCHIVE_DIRECTORY[this]}"
	THIS_ARCHIVE_FILE_SYSTEM="${ARCHIVE_FILE_SYSTEM[this]}"
	THIS_ARCHIVE_DIRECTORY="${ARCHIVE_DIRECTORY[this]}"
	ARCHIVE_TAR_FILE="$HOSTNAME-$START_DATESTAMP.gz"
		ARCHIVE_TAR_FULL="$THIS_ARCHIVE_DIRECTORY/$ARCHIVE_TAR_FILE"
	ARCHIVE_TAR_WEEKDAY_FILE="$HOSTNAME-weekday-$START_WEEKDAYSTAMP3.gz"
		ARCHIVE_TAR_FULL_WEEKDAY="$THIS_ARCHIVE_DIRECTORY/$ARCHIVE_TAR_WEEKDAY_FILE"
	ARCHIVE_TAR_DAY_FILE="$HOSTNAME-day-$START_DAYSTAMP.gz"
		ARCHIVE_TAR_FULL_DAY="$THIS_ARCHIVE_DIRECTORY/$ARCHIVE_TAR_DAY_FILE"
	ARCHIVE_TAR_MONTH_FILE="$HOSTNAME-month-$START_MONTHSTAMP.gz"
		ARCHIVE_TAR_FULL_MONTH="$THIS_ARCHIVE_DIRECTORY/$ARCHIVE_TAR_MONTH_FILE"
	PLEX_BACKUP_APPLICATION_SUPPORT="$THIS_ARCHIVE_DIRECTORY/plex/Application Support"

	declare -A COLD_BACKUP_FILE_SYSTEM
		COLD_BACKUP_FILE_SYSTEM[default]="${ARCHIVE_FILE_SYSTEM[default]}"
		COLD_BACKUP_FILE_SYSTEM[adam]="${ARCHIVE_FILE_SYSTEM[adam]}"
		COLD_BACKUP_FILE_SYSTEM[nuc01]="${ARCHIVE_FILE_SYSTEM[nuc01]}"
		COLD_BACKUP_FILE_SYSTEM[oz]="${ARCHIVE_FILE_SYSTEM[oz]}"
		if [ -z "${COLD_BACKUP_FILE_SYSTEM[$HOSTNAME]}" ]; then
			if [ -z "$COLD_BACKUP_FILE_SYSTEM[default]" ]; then unset COLD_BACKUP_FILE_SYSTEM[this];
				else COLD_BACKUP_FILE_SYSTEM[this]="${COLD_BACKUP_FILE_SYSTEM[default]}"; fi;
			else COLD_BACKUP_FILE_SYSTEM[this]="${COLD_BACKUP_FILE_SYSTEM[$HOSTNAME]}"; fi
		COLD_BACKUP_FILE_SYSTEM="$THIS_ARCHIVE_FILE_SYSTEM"
	declare -A COLD_BACKUP_FS_READ_ONLY
		COLD_BACKUP_FS_READ_ONLY[default]=false
		COLD_BACKUP_FS_READ_ONLY[adam]=false
		COLD_BACKUP_FS_READ_ONLY[nuc01]=false
		COLD_BACKUP_FS_READ_ONLY[oz]=false
		if [ -z "${COLD_BACKUP_FS_READ_ONLY[$HOSTNAME]}" ]; then
			if [ -z "$COLD_BACKUP_FS_READ_ONLY[default]" ]; then unset COLD_BACKUP_FS_READ_ONLY[this];
				else COLD_BACKUP_FS_READ_ONLY[this]="${COLD_BACKUP_FS_READ_ONLY[default]}"; fi;
			else COLD_BACKUP_FS_READ_ONLY[this]="${COLD_BACKUP_FS_READ_ONLY[$HOSTNAME]}"; fi
		COLD_BACKUP_FS_READ_ONLY="${COLD_BACKUP_FS_READ_ONLY[this]}"

	declare -A COLD_BACKUP_PARENT_DIRECTORY
		COLD_BACKUP_PARENT_DIRECTORY[default]="/var/local"
		COLD_BACKUP_PARENT_DIRECTORY[adam]="${COLD_BACKUP_FILE_SYSTEM[adam]}"
		COLD_BACKUP_PARENT_DIRECTORY[nuc01]="${COLD_BACKUP_FILE_SYSTEM[nuc01]}"
		COLD_BACKUP_PARENT_DIRECTORY[oz]="${COLD_BACKUP_FILE_SYSTEM[oz]}"
		if [ -z "${COLD_BACKUP_PARENT_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$COLD_BACKUP_PARENT_DIRECTORY[default]" ]; then unset COLD_BACKUP_PARENT_DIRECTORY[this];
				else COLD_BACKUP_PARENT_DIRECTORY[this]="${COLD_BACKUP_PARENT_DIRECTORY[default]}"; fi;
			else COLD_BACKUP_PARENT_DIRECTORY[this]="${COLD_BACKUP_PARENT_DIRECTORY[$HOSTNAME]}"; fi
		COLD_BACKUP_PARENT_DIRECTORY="${COLD_BACKUP_PARENT_DIRECTORY[this]}"
	declare -A COLD_BACKUP_SUBDIRECTORY
		COLD_BACKUP_SUBDIRECTORY[default]="cold-backup"
		COLD_BACKUP_SUBDIRECTORY[adam]="${COLD_BACKUP_SUBDIRECTORY[default]}"
		COLD_BACKUP_SUBDIRECTORY[nuc01]="${COLD_BACKUP_SUBDIRECTORY[default]}"
		COLD_BACKUP_SUBDIRECTORY[oz]="${COLD_BACKUP_SUBDIRECTORY[default]}"
		if [ -z "${COLD_BACKUP_SUBDIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$COLD_BACKUP_SUBDIRECTORY[default]" ]; then unset COLD_BACKUP_SUBDIRECTORY[this];
				else COLD_BACKUP_SUBDIRECTORY[this]="${COLD_BACKUP_SUBDIRECTORY[default]}"; fi;
			else COLD_BACKUP_SUBDIRECTORY[this]="${COLD_BACKUP_SUBDIRECTORY[$HOSTNAME]}"; fi
		COLD_BACKUP_SUBDIRECTORY="${COLD_BACKUP_SUBDIRECTORY[this]}"
	declare -A COLD_BACKUP_PARENT_DIRECTORY
		COLD_BACKUP_PARENT_DIRECTORY[default]="${COLD_BACKUP_FILE_SYSTEM[default]}"
		COLD_BACKUP_PARENT_DIRECTORY[adam]="${COLD_BACKUP_FILE_SYSTEM[adam]}"
		COLD_BACKUP_PARENT_DIRECTORY[nuc01]="${COLD_BACKUP_FILE_SYSTEM[nuc01]}"
		COLD_BACKUP_PARENT_DIRECTORY[oz]="${COLD_BACKUP_FILE_SYSTEM[oz]}"
		if [ -z "${COLD_BACKUP_PARENT_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$COLD_BACKUP_PARENT_DIRECTORY[default]" ]; then unset COLD_BACKUP_PARENT_DIRECTORY[this];
				else COLD_BACKUP_PARENT_DIRECTORY[this]="${COLD_BACKUP_PARENT_DIRECTORY[default]}"; fi;
			else COLD_BACKUP_PARENT_DIRECTORY[this]="${COLD_BACKUP_PARENT_DIRECTORY[$HOSTNAME]}"; fi
		COLD_BACKUP_PARENT_DIRECTORY="${COLD_BACKUP_PARENT_DIRECTORY[this]}"
	declare -A TEMP_COLD_BACKUP_PARENT_DIRECTORY
		TEMP_COLD_BACKUP_PARENT_DIRECTORY[default]="${TEMP_ROOT[default]}"
		TEMP_COLD_BACKUP_PARENT_DIRECTORY[adam]="${TEMP_ROOT[adam]}"
		TEMP_COLD_BACKUP_PARENT_DIRECTORY[nuc01]="${TEMP_ROOT[nuc01]}"
		TEMP_COLD_BACKUP_PARENT_DIRECTORY[oz]="${TEMP_ROOT[oz]}"
		if [ -z "${TEMP_COLD_BACKUP_PARENT_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$TEMP_COLD_BACKUP_PARENT_DIRECTORY[default]" ]; then unset TEMP_COLD_BACKUP_PARENT_DIRECTORY[this];
				else TEMP_COLD_BACKUP_PARENT_DIRECTORY[this]="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[default]}"; fi;
			else TEMP_COLD_BACKUP_PARENT_DIRECTORY[this]="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[$HOSTNAME]}"; fi
		TEMP_COLD_BACKUP_PARENT_DIRECTORY="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[this]}"
	declare -A TEMP_COLD_BACKUP_SUBDIRECTORY
		TEMP_COLD_BACKUP_SUBDIRECTORY[default]="cold-backup"
		TEMP_COLD_BACKUP_SUBDIRECTORY[adam]="${TEMP_COLD_BACKUP_SUBDIRECTORY[default]}"
		TEMP_COLD_BACKUP_SUBDIRECTORY[nuc01]="${TEMP_COLD_BACKUP_SUBDIRECTORY[default]}"
		TEMP_COLD_BACKUP_SUBDIRECTORY[oz]="${TEMP_COLD_BACKUP_SUBDIRECTORY[default]}"
		if [ -z "${TEMP_COLD_BACKUP_SUBDIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$TEMP_COLD_BACKUP_SUBDIRECTORY[default]" ]; then unset TEMP_COLD_BACKUP_SUBDIRECTORY[this];
				else TEMP_COLD_BACKUP_SUBDIRECTORY[this]="${TEMP_COLD_BACKUP_SUBDIRECTORY[default]}"; fi;
			else TEMP_COLD_BACKUP_SUBDIRECTORY[this]="${TEMP_COLD_BACKUP_SUBDIRECTORY[$HOSTNAME]}"; fi
		TEMP_COLD_BACKUP_SUBDIRECTORY="${TEMP_COLD_BACKUP_SUBDIRECTORY[this]}"
	declare -A TEMP_COLD_BACKUP_DIRECTORY
		TEMP_COLD_BACKUP_DIRECTORY[default]="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[default]}/${TEMP_COLD_BACKUP_SUBDIRECTORY[default]}"
		TEMP_COLD_BACKUP_DIRECTORY[adam]="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[adam]}/${TEMP_COLD_BACKUP_SUBDIRECTORY[adam]}"
		TEMP_COLD_BACKUP_DIRECTORY[nuc01]="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[nuc01]}/${TEMP_COLD_BACKUP_SUBDIRECTORY[nuc01]}"
		TEMP_COLD_BACKUP_DIRECTORY[oz]="${TEMP_COLD_BACKUP_PARENT_DIRECTORY[oz]}/${TEMP_COLD_BACKUP_SUBDIRECTORY[oz]}"
		if [ -z "${TEMP_COLD_BACKUP_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$TEMP_COLD_BACKUP_DIRECTORY[default]" ]; then unset TEMP_COLD_BACKUP_DIRECTORY[this];
				else TEMP_COLD_BACKUP_DIRECTORY[this]="${TEMP_COLD_BACKUP_DIRECTORY[default]}"; fi;
			else TEMP_COLD_BACKUP_DIRECTORY[this]="${TEMP_COLD_BACKUP_DIRECTORY[$HOSTNAME]}"; fi
		TEMP_COLD_BACKUP_DIRECTORY="${TEMP_COLD_BACKUP_DIRECTORY[this]}"
	declare -A TEMP_ARCHIVE_PARENT_DIRECTORY
		TEMP_ARCHIVE_PARENT_DIRECTORY[default]="${TEMP_ROOT[default]}"
		TEMP_ARCHIVE_PARENT_DIRECTORY[adam]="${TEMP_ROOT[adam]}"
		TEMP_ARCHIVE_PARENT_DIRECTORY[nuc01]="${TEMP_ROOT[nuc01]}"
		TEMP_ARCHIVE_PARENT_DIRECTORY[oz]="${TEMP_ROOT[oz]}"
		if [ -z "${TEMP_ARCHIVE_PARENT_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$TEMP_ARCHIVE_PARENT_DIRECTORY[default]" ]; then unset TEMP_ARCHIVE_PARENT_DIRECTORY[this];
				else TEMP_ARCHIVE_PARENT_DIRECTORY[this]="${TEMP_ARCHIVE_PARENT_DIRECTORY[default]}"; fi;
			else TEMP_ARCHIVE_PARENT_DIRECTORY[this]="${TEMP_ARCHIVE_PARENT_DIRECTORY[$HOSTNAME]}"; fi
		TEMP_ARCHIVE_PARENT_DIRECTORY="${TEMP_ARCHIVE_PARENT_DIRECTORY[this]}"
	declare -A TEMP_ARCHIVE_SUBDIRECTORY
		TEMP_ARCHIVE_SUBDIRECTORY[default]="archives"
		TEMP_ARCHIVE_SUBDIRECTORY[adam]="${TEMP_ARCHIVE_SUBDIRECTORY[default]}"
		TEMP_ARCHIVE_SUBDIRECTORY[nuc01]="${TEMP_ARCHIVE_SUBDIRECTORY[default]}"
		TEMP_ARCHIVE_SUBDIRECTORY[oz]="${TEMP_ARCHIVE_SUBDIRECTORY[default]}"
		if [ -z "${TEMP_ARCHIVE_SUBDIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$TEMP_ARCHIVE_SUBDIRECTORY[default]" ]; then unset TEMP_ARCHIVE_SUBDIRECTORY[this];
				else TEMP_ARCHIVE_SUBDIRECTORY[this]="${TEMP_ARCHIVE_SUBDIRECTORY[default]}"; fi;
			else TEMP_ARCHIVE_SUBDIRECTORY[this]="${TEMP_ARCHIVE_SUBDIRECTORY[$HOSTNAME]}"; fi
		TEMP_ARCHIVE_SUBDIRECTORY="${TEMP_ARCHIVE_SUBDIRECTORY[this]}"
	declare -A TEMP_ARCHIVE_DIRECTORY
		TEMP_ARCHIVE_DIRECTORY[default]="${TEMP_ARCHIVE_PARENT_DIRECTORY[default]}/${TEMP_ARCHIVE_SUBDIRECTORY[default]}"
		TEMP_ARCHIVE_DIRECTORY[adam]="${ARCHIVE_FILE_SYSTEM[adam]}/${TEMP_ARCHIVE_SUBDIRECTORY[adam]}"
		TEMP_ARCHIVE_DIRECTORY[nuc01]="${ARCHIVE_FILE_SYSTEM[nuc01]}/${TEMP_ARCHIVE_SUBDIRECTORY[nuc01]}"
		TEMP_ARCHIVE_DIRECTORY[oz]="${ARCHIVE_FILE_SYSTEM[oz]}/${TEMP_ARCHIVE_SUBDIRECTORY[oz]}"
		if [ -z "${TEMP_ARCHIVE_DIRECTORY[$HOSTNAME]}" ]; then
			if [ -z "$TEMP_ARCHIVE_DIRECTORY[default]" ]; then unset TEMP_ARCHIVE_DIRECTORY[this];
				else TEMP_ARCHIVE_DIRECTORY[this]="${TEMP_ARCHIVE_DIRECTORY[default]}"; fi;
			else TEMP_ARCHIVE_DIRECTORY[this]="${TEMP_ARCHIVE_DIRECTORY[$HOSTNAME]}"; fi
		TEMP_ARCHIVE_DIRECTORY="${TEMP_ARCHIVE_DIRECTORY[this]}"




# About This Script (or at least the one sourcing it)
	PROGRAM_DIRECTORY="$(dirname $0)"
	UUID="$(uuidgen)"

# Current user info
	CURRENT_USER="$USER"
	CURRENT_HOME_DIR="$HOME"

# Admin user info
# Dependent on section Global
	ADMIN_USER=lhensley
	ADMIN_HOME_DIR="$HOME_ROOT/$ADMIN_USER"
	ADMIN_CELL_EMAIL=7608514641@vtext.com
	ADMIN_EMAIL=lane@lanehensley.org
	ADMIN_NAME="Lane Hensley"

# Root user info
	ROOT_USER=root
	ROOT_HOME_DIR=/root
	ROOT_EMAIL=root@$HOSTNAME.$DOMAIN_NAME
	ROOT_NAME="root at $HOSTNAME.$DOMAIN_NAME"

# Temp file definitions
# DEPENDENT ON ABOUT THIS SCRIPT ABOVE
	TEMP_CRON="/tmp/cron-$UUID.tmp"
	TEMP_SOCKETS_BACKUP="/tmp/sockets-$UUID.tmp"         # Formerly $SOCKETS_TEMP_FILE
	TEMP_DATABASES="/tmp/databases-$UUID.tmp"
	TEMP_PASSWORD_INCLUDE="/tmp/passwords"
	TEMP_INCLUDES="/tmp/includes-$UUID.tmp"
	TEMP_LOG="/tmp/log-$UUID.tmp"

# Logging:  system.log-level: 0=none 1=light 2=normal 3=heavy 5=everything
	#CONFIG_system_log_level
	LOG_LEVEL=2
	TEXT_LEVEL=2
	# Set to false 11/25/2020. Do it manually if you want it.
	LOG_START=false
	# Set to false 11/25/2020. Do it manually if you want it.
	LOG_END=false

# Exit codes
	EXIT_CODE_SUCCESS=0
	EXIT_CODE_INTERNAL_ERROR=61
	EXIT_CODE_INVALID_OPTIONS=62
	EXIT_CODE_ROOT_REQUIRED=63
	EXIT_CODE_UBUNTU_REQUIRED=64
	EXIT_CODE_MINIMUM_OS_VERSION_REQUIRED=65
	EXIT_CODE_MAXIMUM_OS_VERSION_REQUIRED=66
	EXIT_CODE_SPECIFIC_SERVER_REQUIRED=67
	EXIT_CODE_USER_ABORT=68
	EXIT_CODE_FILE_NOT_FOUND=69
	EXIT_CODE_DIRECTORY_NOT_FOUND=70
	EXIT_CODE_FILE_IN_USE=71
	EXIT_CODE_WRONG_HOST=72
	EXIT_CODE_SEGMENTATION_ERROR=139 # Returned by HandBrakeCLI

# Text Alerts
# DEPENDENT on user definitions above
# Set as many as desired. Must be email addresses that forward to SMS
# Example: TEXT_ALERT[becky]=7608515830@vtext.com
	declare -A TEXT_ALERT
	TEXT_ALERT[admin]="$ADMIN_CELL_EMAIL"
	TEXT_ALERTS=""
	for KEY in "${!TEXT_ALERT[@]}"; do TEXT_ALERTS+="${TEXT_ALERT[$KEY]} "; done

# Text Markup Codes
#	BOLD="$(tput bold)"
#	NORMAL="$(tput sgr0)"
#	UNDERLINE="$(tput smul)"
#	DIM="$(tput dim)"
#	REVERSE="$(tput rev)"
#	STANDOUT="$(tput smso)"
#	BLACK="$(tput setf 0)"
#	BLUE="$(tput setf 1)"
#	GREEN="$(tput setf 2)"
#	CYAN="$(tput setf 3)"
#	RED="$(tput setf 4)"
#	MAGENTA="$(tput setf 5)"
#	YELLOW="$(tput setf 6)"
#	WHITE="$(tput setf 7)"

# Email Alerts
# DEPENDENT on user definitions above
# Set as many as desired.
# Example: EMAIL_ALERT[becky]=rkh@georgetown.edu
	declare -A EMAIL_ALERT
	EMAIL_ALERT[admin]="$ADMIN_EMAIL"
	EMAIL_ALERTS=""
	for KEY in "${!EMAIL_ALERT[@]}"; do EMAIL_ALERTS+="${EMAIL_ALERT[$KEY]} "; done

# Apache2
	WEB_ROOTS="/var/www"
	THIS_WEB_ROOT="$WEB_ROOTS/html"

# Backup COLD # cold backup
# DEPENDENT on definition of $HOSTNAME, but that's built-in
	# Adjusted 12/30/2020 because none of these services were coming back.
	# COLD_PROTECTED_SERVICES="apache2 cron ddclient fail2ban lsyncd mysql plexmediaserver postfix proftpd tautulli webmin"
	COLD_PROTECTED_SERVICES="mysql postfix"
		# Previously incuded gdm3, but that turns off the console.

# Default COLD_RESTORE_POINT = "/", but "/var/restore-points/$START_DATEANDTIMESTAMP/" recommended for trouble-shooting
		COLD_RESTORE_POINT="/"
		# COLD_RESTORE_POINT="/var/restore-points/$START_DATEANDTIMESTAMP/"
	COLD_BACKUP_LOG="$ADMIN_HOME_DIR/.coldstorage.log"

	COLD_BACKUP_DIRECTORY="$COLD_BACKUP_PARENT_DIRECTORY/$COLD_BACKUP_SUBDIRECTORY"
	COLD_BACKUP_EXCLUDES="--exclude='/var/lib/plexmediaserver/Library/Application Support/Plex Media Server/Cache'"
	COLD_BACKUP_EXCLUDES+=" --exclude=/var/lib/plexmediaserver/Library/store/*"
	COLD_BACKUP_EXCLUDES+=" --exclude=/var/lib/plexmediaserver/Library/work/*"
	COLD_BACKUP_EXCLUDES+=" --exclude=.cache"
	COLD_BACKUP_EXCLUDES+=" --exclude=Cache"
	COLD_BACKUP_SOURCES="$COLD_BACKUP_EXCLUDES etc home opt root"
	COLD_BACKUP_SOURCES+=" var/www"
	COLD_BACKUP_SOURCES+=" var/lib/plexmediaserver/Library"
	COLD_RESTORE_EXCLUDES="--exclude=.config/os-install-info.txt"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/fstab*"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/systemd/system"
#	COLD_RESTORE_EXCLUDES+=" --exclude=.cache"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/mtab"
#	COLD_RESTORE_EXCLUDES+=" --exclude='/var/lib/plexmediaserver/Library/Application Support/Plex Media Server/Cache'"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/os-release"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/rc*"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/udisks2"
	COLD_RESTORE_EXCLUDES+=" --exclude=etc/whoopsie"

# crontab backups & restores
	CRONTAB_BACKUP_USERS="$ROOT_USER $ADMIN_USER"

# ddclient
	DDCLIENT_INTERVAL=7200

# File System Backups
# DEPENDENT on Archive Directories AND Start Timestamps above
	BACKUP_ROOT="/"										 # Formerly "DIRECTORY_FROM"
	declare -A BACKUP_OPTION
	BACKUP_OPTION[--create]=true
	BACKUP_OPTION[--gzip]=true 
	BACKUP_OPTION[--auto-compress]=true
	BACKUP_OPTION[--preserve-permissions]=true
	BACKUP_OPTION[--file=$TEMP_ARCHIVE_DIRECTORY/$ARCHIVE_TAR_WEEKDAY_FILE]=true
#	BACKUP_OPTION[--exclude --exclude=/mnt/bob/cold-backup/var/lib/plexmediaserver/Library]=true
#	BACKUP_OPTION[--exclude --exclude=/var/lib/plexmediaserver/Library]=true
#	BACKUP_OPTION[--exclude='plexmediaserver/Library/Application Support/Cache']=true
#	BACKUP_OPTION[--exclude=plexmediaserver/Library/work/movies]=true
#	BACKUP_OPTION[--exclude=plexmediaserver/Library/work/tv]=true
	BACKUP_OPTION[--exclude-vcs]=true
	BACKUP_OPTION[--exclude-caches]=true
	BACKUP_OPTION[--totals]=true
	BACKUP_OPTION[--verbose]=true
	# BACKUP_OPTION[--exclude-from="$TEMP_SOCKETS_BACKUP"]=true
	# Ref: https://bytefreaks.net/gnulinux/bash/bash-how-to-iterate-over-associative-array-and-print-all-keyvalue-pairs
	BACKUP_OPTIONS=""; 
	for KEY in "${!BACKUP_OPTION[@]}"; do BACKUP_OPTIONS+=$KEY" "; done
	declare -A BACKUP_SOURCE
	BACKUP_SOURCE[/etc]=true
	BACKUP_SOURCE[/home]=true
	BACKUP_SOURCE[/root]=true
	BACKUP_SOURCE[/usr/local/sbin]=true
	BACKUP_SOURCE[/var/www]=true
	# BACKUP_SOURCE[/var/local/archives/*.sql]=true
	# Ref: https://bytefreaks.net/gnulinux/bash/bash-how-to-iterate-over-associative-array-and-print-all-keyvalue-pairs
	BACKUP_SOURCES=""; for KEY in "${!BACKUP_SOURCE[@]}"; do BACKUP_SOURCES+=$KEY" "; done

# Git
	GIT_BRANCH="master"
	# GIT_BRANCH="dev"
	GIT_ROOT="/var/local/git"                            # Formerly system.git
	GIT_GO="$GIT_ROOT/go"                                # Formerly system.git.go
	GIT_GO_CONFIGS="$GIT_GO/configs"                     # Formerly system.git.go.configs
	GIT_GO_SBIN="$GIT_GO/sbin"                           # Formerly #system.git.go.sbin
	GIT_GO_SERVICES="$GIT_GO/services"
	GIT_GO_SETUP="$GIT_GO/setup"                         # Formerly system.git.go.setup
	GIT_TOKEN=4b662b7d4431ec1956127aa9d4fdbd8d75ec821a   # Formerly system.git.token
	SERVICES_DIR="/lib/systemd/system"

# HandBrake
# DEPENDENT ON $ADMIN_HOME_DIR DEFINITION ABOVE
	HANDBRAKE_CLI="/usr/bin/HandBrakeCLI"
	HANDBRAKE_PRESETS="$ADMIN_HOME_DIR/.HandBrake/Lane 1080p (BluRay, All Languages).json"

# Incoming Scans
	INCOMING_SCANS="$ADMIN_HOME_DIR/Scans"

# Installation
	OS_INSTALL_INFO_FILE=.config/os-install-info.txt
	OS_INSTALL_INFO_PATH="$ROOT_HOME_DIR/$OS_INSTALL_INFO_FILE"
	
# MakeMKV
	MAKEMKV_OUTPUT_DIRECTORY="$ADMIN_HOME_DIR/Videos/MakeMKV-Completed"
	MAKEMKV_TRANSCODED_FILES_DIRECTORY="$ADMIN_HOME_DIR/Videos/HandBrake-Completed"
	MAKEMKV_FILE_NAME_PATTERN="*.mkv"

# MySQL
	MYSQL_ADMIN_NAME="admin"
	MYSQL_CLIENT_CERTS_DIR="$ADMIN_HOME_DIR/certs"
	MYSQL_CONFIGS="/etc/mysql/conf.d"
	MYSQL_DUMP_DIR="$ADMIN_HOME_DIR/mysql-dumps"
	MYSQL_SERVER_BIN_DIR="/var/lib/mysql"

# MySQL Backups
# DEPENDENT on Archive Directories AND Start Timestamps above
	ARCHIVE_MYSQL_FILE="$HOSTNAME-$START_DATESTAMP.sql"
	ARCHIVE_MYSQL_FULL="$THIS_ARCHIVE_DIRECTORY/$ARCHIVE_MYSQL_FILE"
	ARCHIVE_MYSQL_LITURGY="$THIS_ARCHIVE_DIRECTORY/$HOSTNAME-liturgy.sql"
	ARCHIVE_MYSQL_DB="$THIS_ARCHIVE_DIRECTORY/$HOSTNAME-$START_DATESTAMP-"

# Passwords
	LENGTH_OF_PASSWORDS=60
	MAX_MYSQL_PASSWORD_LENGTH=30
	EXCLUDED_PASSWORD_CHARACTERS=" \$\'\"\\\#\|\<\>\;\*\&\~\!\I\l\1\O\0\`\/\?"

# phpMyAdmin
	PHPMYADMIN_DIR="/usr/share/phpmyadmin"

# Plex Media Server
# DEPENDENT on Archives Directories definitions above
# DEPENDENT on MKMKV above
	PLEX_USER="plex"
	PLEX_VIDEO_FILE_PERMISSIONS=664
	PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS=775
	PLEX_FILE_NAME_PATTERN="*.ts"
	unset PLEX_ROOT
	d="/"
	VIDEO_WORK_FILE_SYSTEM="/mnt/bob"
	VIDEO_STORE_FILE_SYSTEM="/mnt/cloteal"
	VIDEO_WORK_DIRECTORY="$VIDEO_WORK_FILE_SYSTEM/plex/dvr/in"
	VIDEO_STORE_DIRECTORY="$VIDEO_STORE_FILE_SYSTEM/plex-dvr"
	PLEX_LIVE_APPLICATION_SUPPORT="/var/lib/plexmediaserver/Library"
	PLEX_BACKUP_FILE_SYSTEM="$THIS_ARCHIVE_FILE_SYSTEM"
	PLEX_BACKUP_APPLICATION_SUPPORT="$THIS_ARCHIVE_DIRECTORY/plex/Application Support"

# Postfix Setup
	MAILNAME="$HOSTNAME"
	MAIN_MAILER_TYPE="'Internet with smarthost'"
	RELAYHOST="mail.twc.com"                                          # Spectrum Internet (DEFAULT for Austin)
#	if [ $HOSTNAME == "nuc01" ]; then RELAYHOST="mail.mchsi.com"; fi  # Mediacom Cable Internet
#	if [ $HOSTNAME == "red" ]; then RELAYHOST="mail.mchsi.com"; fi    # Mediacom Cable Internet

# reset-when-ready
	RESET_FLAG_FILE="/tmp/reset-when-ready"

# SBIN
	SBIN_PERMISSIONS=755

# SERVICES
	SERVICES_DIR="/lib/systemd/system"
	SERVICES_DIR_PERMISSIONS=755
	SERVICES_FILE_PERMISSIONS=644

# System Snapshot File
	SYSTEM_SNAPSHOT_FILE="$ADMIN_HOME_DIR/.system-snapshot-data.csv"
	SYSTEM_SNAPSHOT_JSON_FILE="$ADMIN_HOME_DIR/.system-snapshot-data.json"
	SYSTEM_SNAPSHOT_FILE_PERMISSIONS=640

# Video Processing Defaults
	DEFAULT_VIDEO_FILE_PERMISSIONS=664
	DEFAULT_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS=775
	SOURCE_ROOT="/dev/null"               # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
								          # For DVDs ripped with MakeMKV, this is $MAKEMKV_OUTPUT_DIRECTORY
	unset SOURCE_FILE_NAME_PATTERN        # For Plex DVR, this is "*.ts"
	                                      # For DVDs ripped with MakeMKV, this is "*.mkv"
	TARGET_ROOT="/dev/null"               # For Plex DVR, this is $VIDEO_STORE_DIRECTORY
	unset TARGET_FILE_EXTENSION           # Normally this is ".m4v"
	SET_PLEX_PERMISSIONS=false            # If the output file is part of a Plex Library, this is true; otherwise (default) false
	USE_TV_FILTERS=false                  # Should only be true when converting Plex DVR files. Default is false
	FLATTEN_TARGET_DIRECTORY=false        # Helpful for processing Zoom files or DVD rips. Default is false
	USE_PARENT_DIR_AS_BASENAME=false      # Can be helpful when $FLATTEN_TARGET_DIRECTORY is true
	PREPEND_PARENT_DIR_TO_BASENAME=false  # Can be helpful for processing Zoom files or DVD rips. Default is false
	APPEND_UUID_TO_TARGET_FILE=false	      # Helps create uniqueness so you can have multiple versions of a single DVR episode
	unset TARGET_DIR_OWNER                # Will be used only if defined
	unset TARGET_DIR_PERMISSIONS          # Will be used only if defined
	unset TARGET_FILE_OWNER               # Will be used only if defined
	unset TARGET_FILE_PERMISSIONS         # Will be used only if defined

# ssh
# DEPENENT on timestamps above
	SSHD_CONFIG="/etc/ssh/sshd_config"
	SSH_KEY_NAME="$HOSTNAME-$START_DATEANDTIMESTAMP"

# Zoom Transcoding
	ZOOM_RAW_FILES="$ADMIN_HOME_DIR/zoom/raw"
	ZOOM_TRANSCODED_FILES="$ADMIN_HOME_DIR/zoom/transcoded"
	ZOOM_FILE_NAME_PATTERN="*.mp4"

# Filter TV shows that should be skipped by process_ts
# Set them all as true
# Example: IGNORE_TV_SHOW[CBS This Morning]=true
# It doesn't matter what the value is set to, as long as the key is defined
# A match is found if any part of the test string matches. 
#      For example, "IGNORE_TV_SHOW[CBS This Morning]=true" is defined, 
#      "CBS This Morning Saturday" matches
	declare -A IGNORE_TV_SHOW
	IGNORE_TV_SHOW[.grab]=true
#	IGNORE_TV_SHOW[ABC World News Tonight]=true
#	IGNORE_TV_SHOW[BBC World News]=true
#	IGNORE_TV_SHOW[CBS Evening News]=true
#	IGNORE_TV_SHOW[CBS Morning News]=true
#	IGNORE_TV_SHOW[CBS This Morning]=true
#	IGNORE_TV_SHOW[CBS Weekend News]=true
#	IGNORE_TV_SHOW[Channel 13 News]=true
#	IGNORE_TV_SHOW[Face the Nation]=true
#	IGNORE_TV_SHOW[Good Morning Iowa]=true
#	IGNORE_TV_SHOW[Jimmy Kimmel Live]=true
#	IGNORE_TV_SHOW[KCCI 8 News]=true
#	IGNORE_TV_SHOW[KXAN News]=true
#	IGNORE_TV_SHOW[Meet the Press]=true
#	IGNORE_TV_SHOW[NBC Nightly News]=true
#	IGNORE_TV_SHOW[Sunday Today]=true
#	IGNORE_TV_SHOW[The Late Show]=true
#	IGNORE_TV_SHOW[The Tonight Show]=true
#	IGNORE_TV_SHOW[Today (1952)]=true
#	IGNORE_TV_SHOW[Today in Iowa]=true
	# Ref: https://bytefreaks.net/gnulinux/bash/bash-how-to-iterate-over-associative-array-and-print-all-keyvalue-pairs
	IGNORE_TV_SHOWS=""; for KEY in "${!IGNORE_TV_SHOW[@]}"; do IGNORE_TV_SHOWS+="\"$KEY\" "; done

# Paths to Scripts
	declare -A PATHNAME
	PATHNAME[_apply_configs]="$SBIN_DIR/_apply-configs"
	PATHNAME[_functions]="$SBIN_DIR/_functions"
	PATHNAME[_git]="$SBIN_DIR/_git"
	PATHNAME[_run_apt_update]="$SBIN_DIR/_run_apt_update"
	PATHNAME[_upd]="$SBIN_DIR/_upd"
	PATHNAME[_vars]="$SBIN_DIR/_vars"
	PATHNAME[apt_remove_duplicate_source_entries]="$SBIN_DIR/apt-remove-duplicate_source-entries.py"
	PATHNAME[backup]="$SBIN_DIR/backup"
	PATHNAME[backup_file]="$SBIN_DIR/backup-file"
	PATHNAME[cleanup_and_exit]="$SBIN_DIR/cleanup-and-exit"
	PATHNAME[currenttimeinseconds]="$SBIN_DIR/currenttimeinseconds"
	PATHNAME[db_backup]="$SBIN_DIR/db-backup"
	PATHNAME[ddnscheck]="$SBIN_DIR/ddnscheck"
	PATHNAME[get_config]="$SBIN_DIR/get-config"
	PATHNAME[lgh]="$SBIN_DIR/lgh"
	PATHNAME[lhlib]="$SBIN_DIR/lhlib"
	PATHNAME[loop_forever]="$SBIN_DIR/loop-forever"
	PATHNAME[make_letsencrypt_p12_files]="$SBIN_DIR/make-letsencrypt-p12-files"
	PATHNAME[make_passwords]="$SBIN_DIR/make-passwords"
	PATHNAME[make_ssh_keys]="$SBIN_DIR/make-ssh-keys"
	PATHNAME[makemkvcon]="/usr/bin/makemkvcon"
	PATHNAME[master_loop]="$SBIN_DIR/master-loop"
	PATHNAME[move_scans_to_onedrive]="$SBIN_DIR/move-scans-to-onedrive"
	PATHNAME[process_ts]="$SBIN_DIR/process-ts"
	PATHNAME[process_incoming_scans]="$SBIN_DIR/process-incoming-scans"
	PATHNAME[remove_empty_directories]="$SBIN_DIR/remove-empty-directories"
	PATHNAME[replace_in_file]="$SBIN_DIR/replace-in-file"
	PATHNAME[rip]="$SBIN_DIR/rip"
	PATHNAME[script_footer]="$SBIN_DIR/script-footer"
	PATHNAME[script_setup]="$SBIN_DIR/script-setup"
	PATHNAME[secureserver]="$SBIN_DIR/secureserver"
	PATHNAME[show_plex_ts_files]="$SBIN_DIR/show-plex-ts-files"
	PATHNAME[stopwatch]="$SBIN_DIR/stopwatch"
	PATHNAME[syncplex]="$SBIN_DIR/syncplex"
	PATHNAME[tar]="/bin/tar"
	PATHNAME[transcode_ripped_dvds]="$SBIN_DIR/transcode-ripped-dvds"
	PATHNAME[unlockserver]="$SBIN_DIR/unlockserver"
	PATHNAME[upd]="$SBIN_DIR/upd"
	PATHNAME[vaultclose]="$SBIN_DIR/vaultclose"
	PATHNAME[vaultopen]="$SBIN_DIR/vaultopen"
	PATHNAME[vaultsync]="$SBIN_DIR/vaultsync"
	PATHNAME[xfers]="$SBIN_DIR/xfers"

# Require root to run these scripts (default is false or undefined)
# DEPENDENT ON PATHNAME ARRAY DEFINITION ABOVE
# Example: ROOT_REQUIRED[${PATHNAME[lgh]}]=true
# It doesn't matter what the value is set to, as long as the key is defined
	declare -A ROOT_REQUIRED
	ROOT_REQUIRED[${PATHNAME[_apply_configs]}]=true
	ROOT_REQUIRED[${PATHNAME[_git]}]=true
	ROOT_REQUIRED[${PATHNAME[_upd]}]=true
	ROOT_REQUIRED[${PATHNAME[lgh]}]=true
	ROOT_REQUIRED[${PATHNAME[upd]}]=true

# Disable start message for these scripts
# DEPENDENT ON PATHNAME ARRAY DEFINITION ABOVE
# Example: DISABLE_START_MESSAGE[${PATHNAME[lgh]}]=true
# If the variable is defined at all, it resolves to true, even if the assigned falue is false
	declare -A DISABLE_START_MESSAGE
	# DISABLE_START_MESSAGE[${PATHNAME[timeformat]}]=true

# Disable end message for these scripts
# DEPENDENT ON PATHNAME ARRAY DEFINITION ABOVE
# Example: DISABLE_END_MESSAGE[${PATHNAME[lgh]}]=true
# If the variable is defined at all, it resolves to true, even if the assigned falue is false
	declare -A DISABLE_END_MESSAGE
	# DISABLE_END_MESSAGE[${PATHNAME[timeformat]}]=true

# Restrict some scripts to particular hosts.
# If a script pathname is referenced even once, 
#	the script will run only if the hostname is associated with the script pathname.
# Example: RESTRICT_SCRIPT_TO_HOST[${PATHNAME[lgh]}]=oz
	declare -A RESTRICT_SCRIPT_TO_HOST
	RESTRICT_SCRIPT_TO_HOST[${PATHNAME[show_plex_ts_files]}]=oz
	RESTRICT_SCRIPT_TO_HOST[${PATHNAME[process_incoming_scans]}]=oz
	RESTRICT_SCRIPT_TO_HOST[${PATHNAME[process_ts]}]=oz
	RESTRICT_SCRIPT_TO_HOST[${PATHNAME[rip]}]=oz

# Set a flag to confirm that the variables are defined
	VARIABLES_ARE_DEFINED=true

# Display all defined variables (used only for troubleshooting)
( set -o posix ; set )

# Log the completion
	if [ ! $DEBUG_MODE ]; then
		logger $0: Variables loaded from _vars
		fi
