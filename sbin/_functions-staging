#!/bin/bash
# _functions
# Bash functions for Lane applications

# Check to ensure that variables are defined
	if [ ! $VARIABLES_ARE_DEFINED ]; then echo $0: Variables not defined. Aborting; logger $0: Variables not defined. Aborting; exit 1; fi

# Set a flag to confirm that the functions are not yet defined
	STAGING_FUNCTIONS_ARE_DEFINED=false

###################################################################################################################################3

function f_move_one_file () {
	# This creates the directory structure for the target if it doesn't aleady exist
	# and applies Plex Library directory and file permissions if requested.
	SOURCE_FILE="$1"         # Full path name of source file
	TARGET_FILE="$2"         # Full target path name of target file
	SET_PLEX_PERMISSIONS=$3  # If the output file is part of a Plex Library, this is true; otherwise (default) false
	SHORT_SOURCE=$(basename "$SOURCE_FILE")
	TARGET_DIR=$(dirname "$TARGET_FILE")
	f_log_and_echo "$0: Moving $SHORT_SOURCE" false
	if ! $(f_is_file "$SOURCE_FILE");	  then f_balk "$0: Source file not found: $1" false;                return; fi 
	mkdir -p "$TARGET_DIR"
	if ! $(f_is_directory "$TARGET_DIR"); then f_balk "$0: Target directory not found: $TARGET_DIR" false;  return; fi 
	if $SET_PLEX_PERMISSIONS; then
		chown $PLEX_USER:$PLEX_USER "$TARGET_DIR"
		chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS "$TARGET_DIR"
		fi
	mv "$SOURCE_FILE" "$TARGET_DIR/"
	exit_code=$?
	if [ $exit_code -ne 0 ];				  then f_balk "$0: Can't move '$SOURCE_FILE' to '$TARGET_FILE'";    return; fi
	if $SET_PLEX_PERMISSIONS; then
		chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
		chmod $PLEX_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
		fi
	}

function f_move_completed_handbrake_files () {
	SOURCE_ROOT="$1"        # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	TARGET_ROOT="$2"        # For Plex DVR, this is $VIDEO_STORE_DIRECTORY
	FILE_NAME_PATTERN="$3"  # For most HandBrake output, this is "*.m4v"
	# Move all "$FILE_NAME_PATTERN" files from "$SOURCE_ROOT" to "$TARGET_ROOT".
		find "$SOURCE_ROOT" -type f -name "$FILE_NAME_PATTERN" | while read THIS_FILE; \
			do f_move_one_plex_file "$THIS_FILE" "$TARGET_ROOT/$THIS_FILE"; done
	}

function f_transcode_handbrake_source_video_file () {
	# Replaces f_process_ts_file
	# CRITICAL: Define these variables BEFORE calling this function:
	#   $SOURCE_FILE
	#   $TARGET_FILE_EXTENSION     # Normally this is ".m4v"
	#   $SOURCE_ROOT               # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	#  	     					   # For DVDs ripped with MakeMKV, this is $MAKEMKV_OUTPUT_DIRECTORY
	#   $TARGET_ROOT               # For Plex DVR, this is $VIDEO_STORE_DIRECTORY
	#   $SET_PLEX_PERMISSIONS      # If the output file is part of a Plex Library, this is true; otherwise (default) false
	#   $USE_TV_FILTERS            # Should only be true when converting Plex DVR files. Default is false

	if ! $(f_is_file "$SOURCE_FILE");       then f_balk "$0: Source file not found: $SOURCE_FILE" false;           return; fi 
	if ! $(f_is_directory "$SOURCE_ROOT");  then f_balk "$0: Source root directory not found: $SOURCE_ROOT" false; return; fi 
	if ! $(f_is_directory "$TARGET_ROOT");  then f_balk "$0: Target root directory not found: $TARGET_ROOT" false; return; fi 

	# Calculate definition of $TARGET_FILE
		SOURCE_ROOT_LENGTH=${#SOURCE_ROOT}
		SOURCE_FILE_LENGTH=${#SOURCE_FILE}
		SOURCE_FILE_EXT="${SOURCE_FILE##*.}"
		SOURCE_FILE_EXT_LENGTH="${#SOURCE_FILE_EXT}"
		if $FLATTEN_TARGET_DIRECTORY; then 
			RELATIVE_FILE=$(basename "$SOURCE_FILE")
			if $USE_PARENT_DIR_AS_BASENAME; then T=$(dirname "$SOURCE_FILE"); RELATIVE_FILE=$(basename "$T"); fi
			RELATIVE_FILE_LENGTH=${#RELATIVE_FILE}
		else
			RELATIVE_FILE_LENGTH=$[SOURCE_FILE_LENGTH-SOURCE_ROOT_LENGTH-1]
			RELATIVE_FILE=${SOURCE_FILE: -$RELATIVE_FILE_LENGTH} # Remove SOURCE_ROOT
			if $USE_PARENT_DIR_AS_BASENAME; then T=$(dirname "$SOURCE_FILE"); 
				F=$(basename "$T"); D=$(dirname "$RELATIVE_FILE"); RELATIVE_FILE="$D/$F";
				if [ $SOURCE_FILE_EXT_LENGTH -ne 0 ]; then RELATIVE_FILE+=".$SOURCE_FILE_EXT"; fi
				RELATIVE_FILE_LENGTH=${#RELATIVE_FILE}
				fi 
		fi
		RELATIVE_FILE_NO_EXT_LENGTH=$[RELATIVE_FILE_LENGTH-SOURCE_FILE_EXT_LENGTH-1] # Recalculate relative path length by removing extension length
		RELATIVE_FILE_NO_EXT=${RELATIVE_FILE:0:RELATIVE_FILE_NO_EXT_LENGTH} # Then remove SOURCE_FILE_EXT
		if $PREPEND_PARENT_DIR_TO_BASENAME || $APPEND_UUID_TO_TARGET_FILE ; then
			DD=$(dirname "$RELATIVE_FILE_NO_EXT")
			FF=$(basename "$RELATIVE_FILE_NO_EXT")
			if $PREPEND_PARENT_DIR_TO_BASENAME ; then T=$(dirname "$SOURCE_FILE"); X=$(basename "$T"); FF="$X-$FF"; fi
			if $APPEND_UUID_TO_TARGET_FILE ; then FF+=" - $(uuidgen)"; fi
			RELATIVE_FILE_NO_EXT="$DD/$FF"
			if [ $DD=="." ]; then RELATIVE_FILE_NO_EXT=$FF; fi
			fi
		TARGET_FILE="$TARGET_ROOT/$RELATIVE_FILE_NO_EXT$TARGET_FILE_EXTENSION"

	if ! $(f_variable_has_content "$TARGET_FILE");   then f_balk "$0: Store file undefined" false; return;    fi

	########################################################################################################
	echo "SOURCE_FILE: $SOURCE_FILE"
	echo "  SOURCE_FILE_EXT: $SOURCE_FILE_EXT"
	echo "  RELATIVE_FILE: $RELATIVE_FILE"
	echo "  RELATIVE_FILE_NO_EXT: $RELATIVE_FILE_NO_EXT"
	echo "  IGNORE_TV_SHOWS: $IGNORE_TV_SHOWS"
	echo "  USE_TV_FILTERS: $USE_TV_FILTERS"
	echo "  TARGET_FILE: $TARGET_FILE"
	echo "  SET_PLEX_PERMISSIONS: $SET_PLEX_PERMISSIONS"
	echo "  RUN_AS: $RUN_AS"
	echo "  DD: $DD"
	echo "  FF: $FF"
	echo
	return

	if ! $(f_filter "$SOURCE_FILE" "$IGNORE_TV_SHOWS") || ! $USE_TV_FILTERS; then
		
		# Do the transcoding
		TIMESTART=$(currenttimeinseconds)
		SOURCE_FILE_BASE=$(basename "$SOURCE_FILE")
		f_log_and_echo "$0: Transcoding $SOURCE_FILE" false
		nice "$HANDBRAKE_CLI" --preset-import-file "$HANDBRAKE_PRESETS" -i "$SOURCE_FILE" -o "$TARGET_FILE"
		exit_status=$?
		chown $RUN_AS:$RUN_AS "$TARGET_FILE"
		chmod $DEFAULT_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
		if $SET_PLEX_PERMISSIONS; then
			chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
			chmod $PLEX_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
			fi
		if [ $exit_status -ne 0 ]; then # If the transcoding failed ...
				f_balk "$HANDBRAKE_CLI: FAILED with $exit_status for $SOURCE_FILE" true
			else
				rm "$SOURCE_FILE" # Delete input file
				f_log_and_echo "$0: Transcoding complete in $(timeformat $(( $(currenttimeinseconds) - TIMESTART )))" false
				echo
			fi # End of check for transcoding failure
		fi
	}

f_iterate_handbrake_source_video_files() {
	# ONE pass through all matching source files, invoking f_transcode_handbrake_source_video_file for each
	# CRITICAL: Define these variables BEFORE calling this function:
	#   $SOURCE_FILE_NAME_PATTERN  # For Plex DVR, this is "*.ts"
	#                              # For DVDs ripped with MakeMKV, this is "*.mkv"
	#   $TARGET_FILE_EXTENSION     # Normally this is ".m4v"
	#   $SOURCE_ROOT               # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	#  	     					   # For DVDs ripped with MakeMKV, this is $MAKEMKV_OUTPUT_DIRECTORY
	#   $TARGET_ROOT               # For Plex DVR, this is $VIDEO_STORE_DIRECTORY
	#   $SET_PLEX_PERMISSIONS      # If the output file is part of a Plex Library, this is true; otherwise (default) false
	#   $USE_TV_FILTERS            # Should only be true when converting Plex DVR files. Default is false

	find "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" | while read SOURCE_FILE; \
		do f_transcode_handbrake_source_video_file; done
	}
	
#########################################################################################################

# Set a flag to confirm that the functions are defined
	STAGING_FUNCTIONS_ARE_DEFINED=true

# Log the completion
if [ ! $DEBUG_MODE ]; then
	logger $0: Functions loaded from _functions
	fi

