#!/bin/bash
# file-filter
# Usage: file-filter <in|out> <test-string>
# Takes a test string as a second argument or standard input.
# For <in|out>=in
#   If match found, <test-string> is echoed.
#   If no match found, nothing is echoed.
# For <in|out>=out
#   If match found, nothing is echoed.
#   If no match found, <test-string> is echoed.

production_mode=true
debug_mode=false
# debug_mode=true
if $debug_mode ; then
  set -x
  fi

# Copy command-line arguments over to new array
ARGS=( $@ )

# Read in from piped input, if present, and append to newly-created array
if [ ! -t 0 ]; then
  readarray STDIN_ARGS < /dev/stdin
  ARGS=( $@ ${STDIN_ARGS[@]} )
fi

INITIAL_STATE=true

# Single loop to process all arguments
for ARG in "${ARGS[@]}"; do
  if $INITIAL_STATE; then
    MODE=$ARG
  else
    if [[ "$IN_FILE" != *"ABC World News Tonight"* ]] \
        && [[ "$IN_FILE" != *"BBC World News"* ]] \
        && [[ "$IN_FILE" != *"CBS Evening News"* ]] \
        && [[ "$IN_FILE" != *"CBS Morning News"* ]] \
        && [[ "$IN_FILE" != *"CBS This Morning"* ]] \
        && [[ "$IN_FILE" != *"CBS Weekend News"* ]] \
        && [[ "$IN_FILE" != *"Face the Nation"* ]] \
        && [[ "$IN_FILE" != *"Jimmy Kimmel Live"* ]] \
        && [[ "$IN_FILE" != *"KXAN News"* ]] \
        && [[ "$IN_FILE" != *"Meet the Press"* ]] \
        && [[ "$IN_FILE" != *"NBC Nightly News"* ]] \
        && [[ "$IN_FILE" != *"Sunday Today"* ]] \
        && [[ "$IN_FILE" != *"The Late Show"* ]] \
        && [[ "$IN_FILE" != *"The Tonight Show"* ]] \
        && [[ "$IN_FILE" != *"Today (195"* ]] \
        && [[ "$IN_FILE" != *".grab"* ]]; then
          if [$MODE == "out"]; then
            printf $ARG
            fi
          else if [$MODE == "in"]; then
            printf $ARG
            fi
      fi
    fi
INITIAL_STATE=false
done

echo $MODE
exit 0


if [[ "$IN_FILE" != *"ABC World News Tonight"* ]] \
    && [[ "$IN_FILE" != *"BBC World News"* ]] \
    && [[ "$IN_FILE" != *"CBS Evening News"* ]] \
    && [[ "$IN_FILE" != *"CBS Morning News"* ]] \
    && [[ "$IN_FILE" != *"CBS This Morning"* ]] \
    && [[ "$IN_FILE" != *"CBS Weekend News"* ]] \
    && [[ "$IN_FILE" != *"Face the Nation"* ]] \
    && [[ "$IN_FILE" != *"Jimmy Kimmel Life"* ]] \
    && [[ "$IN_FILE" != *"KXAN News"* ]] \
    && [[ "$IN_FILE" != *"Meet the Press"* ]] \
    && [[ "$IN_FILE" != *"NBC Nightly News"* ]] \
    && [[ "$IN_FILE" != *"Sunday Today"* ]] \
    && [[ "$IN_FILE" != *"The Late Show"* ]] \
    && [[ "$IN_FILE" != *"The Tonight Show"* ]] \
    && [[ "$IN_FILE" != *"Today (195"* ]] \
    && [[ "$IN_FILE" != *".grab"* ]]; then

    sudo -u lhensley transcode >> /dev/null 2>&1 # Pick up ripped DVDs first, if any

    # Do the transcoding
    TIMESTART=$(currenttimeinseconds)
    logger "$HANDBRAKE starting transcoding of $IN_FILE"
    $HANDBRAKE --preset-import-file "$PRESET" \
        -i "$IN_FILE" -o "$OUT_FILE" >> /dev/null 2>&1
    exit_status=$?
    if [ $exit_status -ne 0 ]; then # If the transcoding failed ...
        logger "$HANDBRAKE transcoding FAILED for $IN_FILE"
        echo "Transcoding FAILED for $RELATIVE_FILE" | mail lanecell
        exit $exit_status
      else
        rm "$IN_FILE" >> /dev/null 2>&1 # Delete input file
        logger "$HANDBRAKE transcoding complete in $(timeformat $(( $(currenttimeinseconds) - TIMESTART ))) for $OUT_FILE"
      fi # End of check for transcoding failure

    move-one-file "$OUT_FILE" "$WORK_ROOT_PATH" "$STORE_ROOT_PATH"

    # Change permissions for Plex libraries
	find "$WORK_ROOT_PATH" -type d -print -exec chmod 775 {} \; >> /dev/null 2>&1
	find "$WORK_ROOT_PATH" -type f -print -exec chmod 664 {} \; >> /dev/null 2>&1
	find "$STORE_ROOT_PATH" -type d -print -exec chmod 775 {} \; >> /dev/null 2>&1
	find "$STORE_ROOT_PATH" -type f -print -exec chmod 664 {} \; >> /dev/null 2>&1
    chown -R plex:plex "$WORK_ROOT_PATH"
    chown -R plex:plex "$STORE_ROOT_PATH"

    exit $exit_status

fi