#!/bin/bash
# _functions
# Bash functions for Lane applications

# Check to ensure that variables are defined
	if [ ! $VARIABLES_ARE_DEFINED ]; then echo $(basename $0): Variables not defined. Aborting; logger -t "$(basename $0)": Variables not defined. Aborting; exit 1; fi

# Set a flag to confirm that the functions are not yet defined
FUNCTIONS_ARE_DEFINED=false

function f_log_and_echo () {
# Usage f_log_and_echo "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
	if $2; then echo $(basename $0): $1 | mail $TEXT_ALERTS; fi
	logger -t "$(basename $0)" $1
	# >&2 echo $(basename $0): $1
	echo $(basename $0): $1
	}

function f_beep () {
	echo -en "\007" # Beep
	}

function f_balk () {
	# Report and log the objection; does NOT exit the program or function
	# Usage: f_balk "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
		f_log_and_echo "$1" "$2"
		f_beep
	}

function f_die () {
	# Usage: f_die "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
	# Note: No need to include $0
		f_balk "$1" "$2"   # report and log the objection
		exit 1             # die
	}

function f_debug () {
    # $1: message to log, only used when $DEBUG_MODE == true
    if [ ! $DEBUG_MODE ]; then
        logger -t "$(basename $0)" DEBUG: $1
        fi
    }

function f_debug_variable () {
    # $1: variable_name
    # $2: variable_value ("$variable_name")
    # Example: f_debug_variable "var" "$var"
    if [ ! $DEBUG_MODE ]; then
        logger -t "$(basename $0)" DEBUG: $1 = $2
        fi
    }

function f_variable_has_content {
	# Usage: if $(f_variable_has_content "$SAMPLE"); then commands_if_true; else commands_if_false; fi
	# $1 = Content of variable, e.g., "$INPUT_FILE"
    if [ -z "$1" ]; then echo false; else echo true; fi
    }

function f_require_value {
	# $1 = Variable name  e.g., "INPUT_FILE"
	# $2 = Content of variable, e.g., "$INPUT_FILE"
	# $3 = Send text alert (true or false)
    if ! $(f_variable_has_content "$2"); then f_die "FATAL: Value of $1 undefined at line ${BASH_LINENO[$i]}" false; fi
    }

function f_is_file {
	# Usage: if $(f_is_file "file_or_path_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -f "$1" ]; then echo true; else echo false; fi
	}

function f_require_file {
    # Usage: f_require_file "file_or_path_name" "send_text_alert_true_or_false"
	if ! $(f_is_file "$1"); then f_die "FATAL: File not found: $1 at line ${BASH_LINENO[$i]}" false; fi
    }

function f_is_directory {
	# Usage: if $(f_is_directory "directory_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -d "$1" ]; then echo true; else echo false; fi
	}

function f_require_directory {
    # Usage: f_require_directory "directory_name" "send_text_alert_true_or_false"
	if ! $(f_is_directory "$1"); then f_die "FATAL: Directory not found: $1 at line ${BASH_LINENO[$i]}" false; fi
    }

function f_require_true {
    # Usage: f_require_true "true_or_false_proposition" "send_text_alert_true_or_false" "failure_message"
	# Example: f_require_true false true "Proposition fails. Sending text alerts."
	if [ ! "$1" ]; then f_die "$2" $3; fi
    }

function f_file_not_in_use {
	# Usage: f_file_not_in_use "file_that_must_not_be_in_use" "failure_message" "send_text_alert_true_or_false"
    f_require_file "$1" false
    if [ -n "$(lsof "$1" 2>/dev/null)" ]; then f_die "$2" "$3"; fi
    }

function f_in_use {
	# Usage: if $(f_in_use "$SAMPLE"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -d -n "$(lsof "$1" 2>/dev/null)" ]; then echo true; else echo false; fi
	}

function f_filter () {
    STRING_BEING_EVALUATED=$1
    FILTER=$2
    MATCH=false

    # Ref: https://superuser.com/questions/1066455/how-to-split-a-string-with-quotes-like-command-arguments-in-bash
    eval "array=($FILTER)"
    for thisfilter in "${array[@]}"; do if [[ $STRING_BEING_EVALUATED == *"$thisfilter"* ]]; then MATCH=true ; fi; done
    echo $MATCH
	}

function f_clear_directory_contents() {
	f_require_directory "$1" false
	rm -rf "$1"/*
	}

function f_local_copy() {
# $1 = source directory; MUST BE A DIRECTORY and not file(s); no trailing slash!
# $2 = target directory; MUST BE A DIRECTORY and not file(s); no trailing slash!
	f_require_directory "$1" false
	f_require_directory "$2" false
	mkdir -p "$2"
	rsync -q -a --delete "$1" "$2"
	# -q = quiet
	# -a = same as -rlptgoD
		# -r = recursive
		# -l = copy symlinks as symlinks
		# -p = preserve permisions
		# -t = preserve modification times
		# -g = preserve group
		# -o = preserve ownership
		# -D = preserve device files and special files
	# --delete = delete extraneous files from dest dirs
	}

function f_install() {
	if ! [ -x "$(command -v $1)" ]; then   
		logger -t "$(basename $0)" Installing $1
		DEBIAN_FRONTEND=noninteractive apt-get install -yq $1
		logger -t "$(basename $0)" Installation of $1 done exit code $?
	fi
	}

function f_chmod() {
# Only one file or directory at a time. No flags, wildcards, or multiple files or directories
	if [ -f "$2" ] || [ -d "$2" ]; then
		chmod $1 $2
	fi
	}

function f_mount_ro_fs_as_rw () {
	FILE_SYSTEM=$1
	# If file system is mounted and read-only, unmount
		if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "ro,") ]; then
			umount "$FILE_SYSTEM"
		fi
	# If file system is not mounted, mount it read-write
		if [ "findmnt $FILE_SYSTEM" ]; then
			mount -o rw "$FILE_SYSTEM"
		fi
	# If file system is not mounted read-write, fail
		if [ ! $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw,") ]; then
			logger -t "$(basename $0)" FATAL: $FILE_SYSTEM is not mounted with rw option
			echo $(basename $0): FATAL: $FILE_SYSTEM is not mounted with rw option
			exit 1
		fi
	}
	
function f_mount_ro_fs_as_ro () {
	FILE_SYSTEM=$1
	FS_READ_ONLY=$2
	# If file system is mounted and read-write, unmount
		if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw,") ]; then
			umount "$FILE_SYSTEM"
		fi
	# If cold backup file system is flagged as ro, unmount & remount ro
	if [ $FS_READ_ONLY ]; then
		mount -o ro "$FILE_SYSTEM"
		fi
	# If file system is not mounted read-only, fail
		if [ ! $(findmnt "$FILE_SYSTEM" -n -o options | grep "ro,") ]; then
			logger -t "$(basename $0)" FATAL: $FILE_SYSTEM is not mounted with ro option
			echo $(basename $0): FATAL: $FILE_SYSTEM is not mounted with ro option
			exit 1
		fi
	}

function f_set_plex_media_recursive_permissions () {
	f_require_directory "$VIDEO_WORK_DIRECTORY" false
    find "$VIDEO_WORK_DIRECTORY" -type d -print -exec chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS {} \;
    find "$VIDEO_WORK_DIRECTORY" -type f -print -exec chmod $PLEX_VIDEO_FILE_PERMISSIONS {} \;
	f_require_directory "$VIDEO_STORE_DIRECTORY" false
    find "$VIDEO_STORE_DIRECTORY" -type d -print -exec chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS {} \;
    find "$VIDEO_STORE_DIRECTORY" -type f -print -exec chmod $PLEX_VIDEO_FILE_PERMISSIONS {} \;
	}

function f_move_one_plex_file () {
	SOURCE_FILE="$1"
	TARGET_FILE="$2"

	SHORT_SOURCE=$(basename "$SOURCE_FILE")
	TARGET_DIR=$(dirname "$TARGET_FILE")
	f_log_and_echo "Moving $SHORT_SOURCE" false
	if ! $(f_is_file "$SOURCE_FILE");                   then f_balk "Source file not found: $1" false;               return; fi 
	mkdir -p "$TARGET_DIR"
	if ! $(f_is_directory "$TARGET_DIR"); then f_balk "Target directory not found: $TARGET_DIR" false;               return; fi 
	chown $PLEX_USER:$PLEX_USER "$TARGET_DIR"
	chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS "$TARGET_DIR"
	mv "$SOURCE_FILE" "$TARGET_DIR/"
	exit_code=$?
	if [ $exit_code -ne 0 ];										then f_balk "Can't move '$SOURCE_FILE' to '$TARGET_FILE'"; return; fi
	chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
	chmod $PLEX_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
	}

function f_relocate_files () {
	THIS_SOURCE_ROOT_DIRECTORY="$1"
	THIS_TARGET_ROOT_DIRECTORY="$2"
	# CRITICAL: How to define the file name mast (with imbedded wildcard)
	# Move all .m4v files from $VIDEO_WORK_DIRECTORY to $VIDEO_STORE_DIRECTORY.
		find "$THIS_SOURCE_ROOT_DIRECTORY" -type f -name "*.m4v" | while read THIS_FILE; do f_move_one_plex_file "$THIS_FILE" "$THIS_TARGET_ROOT_DIRECTORY/$THIS_FILE"; done
	}

function f_process_ts_file () {
	IN_FILE="$1"
	WORK_ROOT_PATH="$2"
	STORE_ROOT_PATH="$3"
	OUT_EXT="m4v"

	if ! $(f_is_file "$IN_FILE");                      then f_balk "TS file not found: $1" false;      return; fi 
	if ! $(f_is_directory "$WORK_ROOT_PATH");          then f_balk "Work directory not found: $1" false; return; fi 
	if ! $(f_is_directory "$STORE_ROOT_PATH");         then f_balk "Store directory not found: $1" false; return; fi 
	if ! $(f_variable_has_content "$IGNORE_TV_SHOWS"); then f_balk "TV filter undefined" false;     return; fi

	WORK_ROOT_PATH_LENGTH=${#WORK_ROOT_PATH}

	IN_FILE_LENGTH=${#IN_FILE}
	IN_FILE_EXT="${IN_FILE##*.}"
	IN_FILE_EXT_LENGTH="${#IN_FILE_EXT}"

	RELATIVE_FILE_LENGTH=$[IN_FILE_LENGTH-WORK_ROOT_PATH_LENGTH-1]
	RELATIVE_FILE=${IN_FILE: -$RELATIVE_FILE_LENGTH} # First remove WORK_ROOT_PATH
	RELATIVE_FILE_NO_EXT_LENGTH=$[RELATIVE_FILE_LENGTH-IN_FILE_EXT_LENGTH-1] # Recalculate relative path length by removing extension length
	RELATIVE_FILE_NO_EXT=${RELATIVE_FILE:0:RELATIVE_FILE_NO_EXT_LENGTH} # Then remove IN_FILE_EXT
	UU=$(uuidgen)
	OUT_FILE="$WORK_ROOT_PATH/$RELATIVE_FILE_NO_EXT - $UU.$OUT_EXT"
	# STORE_FILE="$STORE_ROOT_PATH/$RELATIVE_FILE_NO_EXT - $UU.$OUT_EXT"
	STORE_FILE="$STORE_ROOT_PATH/$RELATIVE_FILE_NO_EXT - $UU.$OUT_EXT"

	if ! $(f_variable_has_content "$OUT_FILE");      then f_balk "Output file undefined" false; return;   fi
	if ! $(f_variable_has_content "$RELATIVE_FILE"); then f_balk "Relative file undefined" false; return; fi
	if ! $(f_variable_has_content "$STORE_FILE");    then f_balk "Store file undefined" false; return;    fi
	if ! $(f_variable_has_content "$PLEX_LIVE_APPLICATION_SUPPORT"); then 
		f_balk "Plex live application support directory undefined" false; return; fi

	if ! $(f_filter "$IN_FILE" "$IGNORE_TV_SHOWS"); then
		
		# Hold this part out for now. Not sure this is the place for it.
		# "${PATHNAME[transcode_ripped_dvds]}" # Pick up ripped DVDs first, if any

		# Do the transcoding
		TIMESTART=$(currenttimeinseconds)
		IN_FILE_BASE=$(basename "$IN_FILE")
		f_log_and_echo "Transcoding $IN_FILE" false
		nice "$HANDBRAKE_CLI" --preset-import-file "$HANDBRAKE_PRESETS" -i "$IN_FILE" -o "$OUT_FILE"
		exit_status=$?
		chown $PLEX_USER:$PLEX_USER "$OUT_FILE"
		chmod $PLEX_VIDEO_FILE_PERMISSIONS "$OUT_FILE"
		if [ $exit_status -ne 0 ]; then # If the transcoding failed ...
				f_balk "$HANDBRAKE_CLI: FAILED with $exit_status for $IN_FILE" true
				return
			else
				rm "$IN_FILE" # Delete input file
				f_log_and_echo "Transcoding complete in $(timeformat $(( $(currenttimeinseconds) - TIMESTART )))" false
				echo
			fi # End of check for transcoding failure
		# Move all .m4v files from $VIDEO_WORK_DIRECTORY to $VIDEO_STORE_DIRECTORY.
			find "$VIDEO_WORK_DIRECTORY" -type f -name "*.m4v" | while read M4V_FILE; do f_move_one_plex_file "$M4V_FILE" "$VIDEO_STORE_DIRECTORY/$M4V_FILE"; done
		echo "Sleeping 10 for diagnostics (so you can read any error messages that may appear above)."
		echo
		sleep 10
		fi
	}

function f_run_apt_updates() {
	# "update" downloads package information from all configured sources
	apt -y update
	# "upgrade" is an extraneous subset of "dist-upgrade" below
	#    sudo apt -y upgrade \
	# "dist-upgrade" installs available upgrades of all packages
	# currently installed on the system and intelligently handles
	# changing dependencies with new versions of packages
	apt -y dist-upgrade
	# "clean" clears out the local repository of retrieved package files.
	apt -y clean
	# "autoremove" removes those dependencies that were installed with
	# now-removed applications and that are no longer used
	# by anything else on the system
	apt -y autoremove
	}

function f_move_one_file () {
	# This creates the directory structure for the target if it doesn't aleady exist
	# and applies Plex Library directory and file permissions if requested.
	SOURCE_FILE="$1"         # Full path name of source file
	TARGET_FILE="$2"         # Full target path name of target file
	SET_PLEX_PERMISSIONS=$3  # If the output file is part of a Plex Library, this is true; otherwise (default) false
	SHORT_SOURCE=$(basename "$SOURCE_FILE")
	TARGET_DIR=$(dirname "$TARGET_FILE")
	f_log_and_echo "Moving $SHORT_SOURCE" false
	if ! $(f_is_file "$SOURCE_FILE");	  then f_balk "Source file not found: $1" false;                return; fi 
	mkdir -p "$TARGET_DIR"
	if ! $(f_is_directory "$TARGET_DIR"); then f_balk "Target directory not found: $TARGET_DIR" false;  return; fi 
	if $SET_PLEX_PERMISSIONS; then
		chown $PLEX_USER:$PLEX_USER "$TARGET_DIR"
		chmod $PLEX_VIDEO_LIBRARY_DIRECTORY_PERMISSIONS "$TARGET_DIR"
		fi
	mv "$SOURCE_FILE" "$TARGET_DIR/"
	exit_code=$?
	if [ $exit_code -ne 0 ];				  then f_balk "Can't move '$SOURCE_FILE' to '$TARGET_FILE'";    return; fi
	if $SET_PLEX_PERMISSIONS; then
		chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
		chmod $PLEX_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
		fi
	}

function f_move_completed_handbrake_files () {
	SOURCE_ROOT="$1"        # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	TARGET_ROOT="$2"        # For Plex DVR, this is $VIDEO_STORE_DIRECTORY
	FILE_NAME_PATTERN="$3"  # For most HandBrake output, this is "*.m4v"
	# Move all "$FILE_NAME_PATTERN" files from "$SOURCE_ROOT" to "$TARGET_ROOT".
		find "$SOURCE_ROOT" -type f -name "$FILE_NAME_PATTERN" | while read THIS_FILE; \
			do f_move_one_plex_file "$THIS_FILE" "$TARGET_ROOT/$THIS_FILE"; done
	}

function f_transcode_handbrake_source_video_file () {
	# Replaces f_process_ts_file
	# CRITICAL: Define these variables BEFORE calling this function:
    # $WAIT_AFTER_SOURCE_SCAN           # How long to wait after looping through all source files
    # $SOURCE_FILE_NAME_PATTERN         # For Plex DVR,                 this is "$PLEX_FILE_NAME_PATTERN"                (defined in _vars)
                                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_FILE_NAME_PATTERN"             (defined in _vars)
                                        # For Zoom meeting recordings,  this is "$ZOOM_FILE_NAME_PATTERN"                (defined in _vars)
    # $SOURCE_ROOT                      # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                  (defined in _vars)
	    	     					    # For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"              (defined in _vars)
	    	     					    # For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                        (defined in _vars)
    # $TARGET_ROOT                      # For Plex DVR, this is "$VIDEO_STORE_DIRECTORY"                                 (defined in _vars)
	    	     					    # For DVDs ripped with MakeMKV, this is "$MAKEMKV_TRANSCODED_FILES_DIRECTORY"    (defined in _vars)
	  	       					        # For Zoom meeting recordings,  this is "$ZOOM_TRANSCODED_FILES"                 (defined in _vars)
    # $TARGET_FILE_EXTENSION            # Normally this is ".m4v"                                                        (default defined in _vars)
    # $SET_PLEX_PERMISSIONS             # Normally true only for Plex content files                                      (default defined in _vars)
    # $USE_TV_FILTERS                   # Normally true only for Plex DVR files                                          (default defined in _vars)
    # $FLATTEN_TARGET_DIRECTORY         # Normally used for Zoom meeting recordings and MAYBE Ripped DVDs (maybe; TBD)   (default defined in _vars)
    # $PREPEND_PARENT_DIR_TO_BASENAME   # Normally used for Zoom meeting recordings                                      (default defined in _vars)
    # $APPEND_UUID_TO_TARGET_FILE       # Normally used for Plex files so that multiple media files can be retained.     (default defined in _vars)
    # $USE_PARENT_DIR_AS_BASENAME       # May be useful for ripped DVDs. TBD. Think about this first                     (default defined in _vars)

	# Try to create $TARGET_ROOT, in case it doesn't yet exist
		mkdir -p "$TARGET_ROOT"

	# Test existence of files and directories
		if ! $(f_is_file "$SOURCE_FILE");       then f_balk "Source file not found: $SOURCE_FILE" false;           return; fi 
		if ! $(f_is_directory "$SOURCE_ROOT");  then f_balk "Source root directory not found: $SOURCE_ROOT" false; return; fi 
		if ! $(f_is_directory "$TARGET_ROOT");  then f_balk "Target root directory not found: $TARGET_ROOT" true;  return; fi

	# Calculate definition of $TARGET_FILE
		SOURCE_ROOT_LENGTH=${#SOURCE_ROOT}
		SOURCE_FILE_LENGTH=${#SOURCE_FILE}
		SOURCE_FILE_EXT="${SOURCE_FILE##*.}"
		SOURCE_FILE_EXT_LENGTH="${#SOURCE_FILE_EXT}"
		if $FLATTEN_TARGET_DIRECTORY; then 
			RELATIVE_FILE=$(basename "$SOURCE_FILE")
			if $USE_PARENT_DIR_AS_BASENAME; then T=$(dirname "$SOURCE_FILE"); RELATIVE_FILE=$(basename "$T"); fi
			RELATIVE_FILE_LENGTH=${#RELATIVE_FILE}
		else
			RELATIVE_FILE_LENGTH=$[SOURCE_FILE_LENGTH-SOURCE_ROOT_LENGTH-1]
			RELATIVE_FILE=${SOURCE_FILE: -$RELATIVE_FILE_LENGTH} # Remove SOURCE_ROOT
			if $USE_PARENT_DIR_AS_BASENAME; then T=$(dirname "$SOURCE_FILE"); 
				F=$(basename "$T"); D=$(dirname "$RELATIVE_FILE"); RELATIVE_FILE="$D/$F";
				if [ $SOURCE_FILE_EXT_LENGTH -ne 0 ]; then RELATIVE_FILE+=".$SOURCE_FILE_EXT"; fi
				RELATIVE_FILE_LENGTH=${#RELATIVE_FILE}
				fi 
		fi
		RELATIVE_FILE_NO_EXT_LENGTH=$[RELATIVE_FILE_LENGTH-SOURCE_FILE_EXT_LENGTH-1] # Recalculate relative path length by removing extension length
		RELATIVE_FILE_NO_EXT=${RELATIVE_FILE:0:RELATIVE_FILE_NO_EXT_LENGTH} # Then remove SOURCE_FILE_EXT
		if $PREPEND_PARENT_DIR_TO_BASENAME || $APPEND_UUID_TO_TARGET_FILE ; then
			DD=$(dirname "$RELATIVE_FILE_NO_EXT")
			FF=$(basename "$RELATIVE_FILE_NO_EXT")
			if $PREPEND_PARENT_DIR_TO_BASENAME ; then T=$(dirname "$SOURCE_FILE"); X=$(basename "$T"); FF="$X-$FF"; fi
			if $APPEND_CURRENT_SERVER_AND_ORIGINAL_RIP_INFO_TO_TARGET_FILE ; 
				then FF+=" - $(hostname -f) date -d \"$(stat -c %z $SOURCE_FILE)\" \"+%Y-%m-%d %H:%M:%S %Z\""; fi
			if $APPEND_UUID_TO_TARGET_FILE ; then FF+=" - $(uuidgen)"; fi
			RELATIVE_FILE_NO_EXT="$DD/$FF"
			if [ "$DD"=="." ]; then RELATIVE_FILE_NO_EXT=$FF; fi
			fi
		TARGET_FILE="$TARGET_ROOT/$RELATIVE_FILE_NO_EXT$TARGET_FILE_EXTENSION"

	if ! $(f_variable_has_content "$TARGET_FILE"); then f_balk "Store file undefined" false; return;    fi

	if ! $(f_filter "$SOURCE_FILE" "$IGNORE_TV_SHOWS") || ! $USE_TV_FILTERS; then
		
	echo TARGET_FILE: $TARGET_FILE
		# Do the transcoding
		TIMESTART=$(currenttimeinseconds)
		SOURCE_FILE_BASE=$(basename "$SOURCE_FILE")
		f_log_and_echo "Transcoding $SOURCE_FILE" false
		nice "$HANDBRAKE_CLI" --preset-import-file "$HANDBRAKE_PRESETS" -i "$SOURCE_FILE" -o "$TARGET_FILE"
		exit_status=$?
		chown $RUN_AS:$RUN_AS "$TARGET_FILE"
		chmod $DEFAULT_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
		if $SET_PLEX_PERMISSIONS; then
	echo #
			chown $PLEX_USER:$PLEX_USER "$TARGET_FILE"
			chmod $PLEX_VIDEO_FILE_PERMISSIONS "$TARGET_FILE"
			fi
		if [ $exit_status -ne 0 ]; then # If the transcoding failed ...
				f_balk "$HANDBRAKE_CLI: FAILED with $exit_status for $SOURCE_FILE" true
			else
				rm "$SOURCE_FILE" # Delete input file
				f_log_and_echo "Transcoding complete in $(timeformat $(( $(currenttimeinseconds) - TIMESTART )))" false
				echo
			fi # End of check for transcoding failure
		fi
	}

f_iterate_handbrake_source_video_files() {
	# ONE pass through all matching source files, invoking f_transcode_handbrake_source_video_file for each
	# CRITICAL: Define these variables BEFORE calling this function:
    # $WAIT_AFTER_SOURCE_SCAN           # How long to wait after looping through all source files
    # $SOURCE_FILE_NAME_PATTERN         # For Plex DVR,                 this is "$PLEX_FILE_NAME_PATTERN"                (defined in _vars)
                                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_FILE_NAME_PATTERN"             (defined in _vars)
                                        # For Zoom meeting recordings,  this is "$ZOOM_FILE_NAME_PATTERN"                (defined in _vars)
    # $SOURCE_ROOT                      # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                  (defined in _vars)
	    	     					    # For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"              (defined in _vars)
	    	     					    # For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                        (defined in _vars)
    # $TARGET_ROOT                      # For Plex DVR, this is "$VIDEO_STORE_DIRECTORY"                                 (defined in _vars)
	    	     					    # For DVDs ripped with MakeMKV, this is "$MAKEMKV_TRANSCODED_FILES_DIRECTORY"    (defined in _vars)
	  	       					        # For Zoom meeting recordings,  this is "$ZOOM_TRANSCODED_FILES"                 (defined in _vars)
    # $TARGET_FILE_EXTENSION            # Normally this is ".m4v"                                                        (default defined in _vars)
    # $SET_PLEX_PERMISSIONS             # Normally true only for Plex content files                                      (default defined in _vars)
    # $USE_TV_FILTERS                   # Normally true only for Plex DVR files                                          (default defined in _vars)
    # $FLATTEN_TARGET_DIRECTORY         # Normally used for Zoom meeting recordings and MAYBE Ripped DVDs (maybe; TBD)   (default defined in _vars)
    # $PREPEND_PARENT_DIR_TO_BASENAME   # Normally used for Zoom meeting recordings                                      (default defined in _vars)
    # $APPEND_UUID_TO_TARGET_FILE       # Normally used for Plex files so that multiple media files can be retained.     (default defined in _vars)
    # $USE_PARENT_DIR_AS_BASENAME       # May be useful for ripped DVDs. TBD. Think about this first                     (default defined in _vars)

	# Do the looping work
		while true; do
			# SOURCE_FILE is the newest file found, based on the sort shown below.
			#   The sort can be fooled by a "newer" directory structure name, because the sort is on the full pathname. 
			#   Oh well. Fix this if that becomes an issue.

			TEMP_FILE="/tmp/source file list $(date)"
			find -L "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" -printf "%T+\t%p\n" | sort -r | cut -f 2 > "$TEMP_FILE"
			while read SOURCE_FILE; do f_transcode_handbrake_source_video_file; logger -t test $SOURCE_FILE; done < "$TEMP_FILE"
			rm "$TEMP_FILE"
			f_log_and_echo "Sleeping $WAIT_AFTER_SOURCE_SCAN." false  # The TRUE part at the end means this sends pager notices.
																	  # Drop this when stable, and consider bumping up the interval.
			sleep "$WAIT_AFTER_SOURCE_SCAN"
			done
	}
	
f_show_eligible_transcoding () {
	# ONE pass through all matching source files, displaying but not processing them
	# CRITICAL: Define these variables BEFORE calling this function:
	#   $SOURCE_FILE_NAME_PATTERN  # For Plex DVR, this is "*.ts"
	#                              # For DVDs ripped with MakeMKV, this is "*.mkv"
	#   $SOURCE_ROOT               # For Plex DVR, this is $VIDEO_WORK_DIRECTORY
	#  	     					   # For DVDs ripped with MakeMKV, this is $MAKEMKV_OUTPUT_DIRECTORY

	find "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" -print
	}
	

#########################################################################################################

# Set a flag to confirm that the functions are defined
	FUNCTIONS_ARE_DEFINED=true

# Log the completion
if [ ! $DEBUG_MODE ]; then
	logger -t "$(basename $0)" Functions loaded from _functions
	fi

