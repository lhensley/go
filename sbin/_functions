#!/bin/bash
# _functions
# Bash functions for Lane applications

# Check to ensure that variables are defined
	if [ ! $VARIABLES_ARE_DEFINED ]; then echo $0: Variables not defined. Aborting; logger $0: Variables not defined. Aborting; exit 1; fi

# Set a flag to confirm that the functions are not yet defined
FUNCTIONS_ARE_DEFINED=false

echo Line ${LINENO}
function f_log_and_echo () {
# Usage f_log_and_echo "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
	if $2; then echo $1 | mail $TEXT_ALERTS; fi
	logger $1
	>&2 echo $1
	}

echo Line ${LINENO}
function f_beep () {
	echo -en "\007" # Beep
	}

echo Line ${LINENO}
function f_balk () {
	# Usage: f_balk "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
		f_log_and_echo "$1" "$2"
		f_beep
	}

echo Line ${LINENO}
function f_die () {
	# Usage: f_die "$MESSAGE_TO_STDERR_AND_LOG" "SEND_TEXT_ALERT_TRUE_OR_FALSE"
		f_balk "$1" "$2"
		exit 1
	}

echo Line ${LINENO}
function f_debug () {
    # $1: message to log, only used when $DEBUG_MODE == true
    if [ ! $DEBUG_MODE ]; then
        logger $0: DEBUG: $1
        fi
    }

echo Line ${LINENO}
function f_debug_variable () {
    # $1: variable_name
    # $2: variable_value ("$variable_name")
    # Example: f_debug_variable "var" "$var"
    if [ ! $DEBUG_MODE ]; then
        logger $0: DEBUG: $1 = $2
        fi
    }

echo Line ${LINENO}
function f_variable_has_content {
	# Usage: if $(f_variable_has_content "$SAMPLE"); then commands_if_true; else commands_if_false; fi
	# $1 = Content of variable, e.g., "$INPUT_FILE"
    if [ -z "$1" ]; then echo false; else echo true; fi
    }

echo Line ${LINENO}
function f_require_value {
# $1 = Variable name  e.g., "INPUT_FILE" "send_text_alert_true_or_false"
# $2 = Content of variable, e.g., "$INPUT_FILE"
    if ! f_variable_has_content "$2"; then f_die "$0: FATAL: Value of $1 undefined. Line ${LINENO}" "$2"; fi
    }

echo Line ${LINENO}
function f_is_file {
	# Usage: if $(f_is_file "file_or_path_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -f "$1" ]; then echo true; else echo false; fi
	}

echo Line ${LINENO}
function f_require_file {
    # Usage: f_require_file "file_or_path_name" "send_text_alert_true_or_false"
	if ! $(f_is_file "$1"); then f_die "$0: FATAL: File not found: $1" "$2"; fi
    }

echo Line ${LINENO}
function f_is_directory {
	# Usage: if $(f_is_directory "directory_name"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -d "$1" ]; then echo true; else echo false; fi
	}

echo Line ${LINENO}
function f_require_directory {
    # Usage: f_require_directory "directory_name" "send_text_alert_true_or_false"
	if ! $(f_is_directory "$1"); then f_die "$0: FATAL: Directory not found: $1" "$2"; fi
    }

echo Line ${LINENO}
function f_require_true {
    # Usage: f_require_true "true_or_false_proposition" "send_text_alert_true_or_false" "failure_message" ;
	if ! $1; then f_die "$2" $3; fi
    }

echo Line ${LINENO}
function f_file_not_in_use {
    f_require_file "$1" false
    if [ -n "$(lsof "$1" 2>/dev/null)" ]; then
	    echo "$0: FATAL: File in use: $1"
	    logger "$0: FATAL: File in use: $1"
        exit 1
        fi
    }

echo Line ${LINENO}
function f_in_use {
	# Usage: if $(f_in_use "$SAMPLE"); then commands_if_true; else commands_if_false; fi
	# $1 = "$string_to_check"
    if [ -d -n "$(lsof "$1" 2>/dev/null)" ]; then echo true; else echo false; fi
	}

echo Line ${LINENO}
function f_filter () {
    STRING_BEING_EVALUATED=$1
    FILTER=$2
    MATCH=false

    # Ref: https://superuser.com/questions/1066455/how-to-split-a-string-with-quotes-like-command-arguments-in-bash
    eval "array=($FILTER)"
    for thisfilter in "${array[@]}"; do if [[ $STRING_BEING_EVALUATED == *"$thisfilter"* ]]; then MATCH=true ; fi; done
    echo $MATCH
	}

echo Line ${LINENO}
function f_clear_directory_contents() {
	f_require_directory "$1" false
	rm -rf "$1"/*
	}

echo Line ${LINENO}
function f_local_copy() {
# $1 = source directory; MUST BE A DIRECTORY and not file(s); no trailing slash!
# $2 = target directory; MUST BE A DIRECTORY and not file(s); no trailing slash!
	f_require_directory "$1" false
	f_require_directory "$2" false
	mkdir -p "$2"
	rsync -q -a --delete "$1" "$2"
	# -q = quiet
	# -a = same as -rlptgoD
		# -r = recursive
		# -l = copy symlinks as symlinks
		# -p = preserve permisions
		# -t = preserve modification times
		# -g = preserve group
		# -o = preserve ownership
		# -D = preserve device files and special files
	# --delete = delete extraneous files from dest dirs
	}

# Set a flag to confirm that the functions are defined
	FUNCTIONS_ARE_DEFINED=true

echo Line ${LINENO}
function f_install() {
	if ! [ -x "$(command -v $1)" ]; then   
		logger $0 Installing $1
		DEBIAN_FRONTEND=noninteractive apt-get install -yq $1
		logger $0 Installation of $1 done exit code $?
	fi
	}

echo Line ${LINENO}
function f_chmod() {
# Only one file or directory at a time. No flags, wildcards, or multiple files or directories
	if [ -f "$2" ] || [ -d "$2" ]; then
		chmod $1 $2
	fi
	}

echo Line ${LINENO}
function f_mount_ro_fs_as_rw () {
	FILE_SYSTEM=$1
	# If file system is mounted and read-only, unmount
		if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "ro,") ]; then
			umount "$FILE_SYSTEM"
		fi
	# If file system is not mounted, mount it read-write
		if [ "findmnt $FILE_SYSTEM" ]; then
			mount -o rw "$FILE_SYSTEM"
		fi
	# If file system is not mounted read-write, fail
		if [ ! $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw,") ]; then
			logger $0: FATAL: $FILE_SYSTEM is not mounted with rw option
			echo $0: FATAL: $FILE_SYSTEM is not mounted with rw option
			exit 1
		fi
	}

echo Line ${LINENO}
function f_mount_ro_fs_as_ro () {
echo Line ${LINENO}
	FILE_SYSTEM=$1
	FS_READ_ONLY=$2
	# If file system is mounted and read-write, unmount
		if [ $(findmnt "$FILE_SYSTEM" -n -o options | grep "rw,") ]; then
			umount "$FILE_SYSTEM"
		fi
	# If cold backup file system is flagged as ro, unmount & remount ro
	if [ $FS_READ_ONLY ]; then
		mount -o ro "$FILE_SYSTEM"
		fi
	# If file system is not mounted read-only, fail
		if [ ! $(findmnt "$FILE_SYSTEM" -n -o options | grep "ro,") ]; then
			logger $0: FATAL: $FILE_SYSTEM is not mounted with ro option
			echo $0: FATAL: $FILE_SYSTEM is not mounted with ro option
			exit 1
		fi
	}

echo Line ${LINENO}
function f_set_plex_media_recursive_permissions () {
	f_require_directory "$VIDEO_WORK_DIRECTORY" false
    find "$VIDEO_WORK_DIRECTORY" -type d -print -exec chmod 775 {} \;
    find "$VIDEO_WORK_DIRECTORY" -type f -print -exec chmod 664 {} \;
	f_require_directory "$VIDEO_STORE_DIRECTORY" false
    find "$VIDEO_STORE_DIRECTORY" -type d -print -exec chmod 775 {} \;
    find "$VIDEO_STORE_DIRECTORY" -type f -print -exec chmod 664 {} \;
	}

echo Line ${LINENO}
function f_move_one_file () {
	IN_FILE="$1"
	ROOT_IN_PATH="$2"
	ROOT_OUT_PATH="$3"

	ROOT_IN_PATH_LENGTH=${#ROOT_IN_PATH}

	RELATIVE_FILE_LENGTH=$[IN_FILE_LENGTH-ROOT_IN_PATH_LENGTH-1]
	RELATIVE_FILE="${IN_FILE: -$RELATIVE_FILE_LENGTH}" # Remove ROOT_IN_PATH
	}

echo Line ${LINENO}
function f_process_ts_file () {
echo Line ${LINENO}
	OUT_FILE="$ROOT_OUT_PATH/$RELATIVE_FILE"
	NEW_DIRECTORY=$(dirname "$OUT_FILE")

echo Line ${LINENO}
	if $(f_in_use "$IN_FILE"); then f_balk "$0: Skipped moving $IN_FILE because it's in use." false
	if ! $(f_is_file "$IN_FILE"); then f_balk "$0: Cannot move non-existent file $IN_FILE." false
	if ! $(f_is_directory "$ROOT_IN_PATH"); then f_balk "$0: Non-existent root in directory $ROOT_IN_PATH." false

echo Line ${LINENO}
	# Make the directory for out file
	mkdir -p "$NEW_DIRECTORY"
	if [ $? -ne 0 ]; then # If mkdir failed failed ...
		f_die "$0: FAILED making $NEW_DIRECTORY" true
		sleep 10 # Add some time here in case we're racing through a failure loop.
		return
	fi
	chown plex:plex "$NEW_DIRECTORY"
	chmod 664 "$NEW_DIRECTORY"

echo Line ${LINENO}
	# Move $IN_FILE to $OUT_FILE
#	f_log_and_echo "$0: Moving $(basename \"$IN_FILE\")"


echo Line ${LINENO}



	}


echo Line ${LINENO}
function f_lane_test () {
	echo "Test A"
	echo Plex Dir: $PLEX_LIVE_APPLICATION_SUPPORT
	}




#########################################################################################################

# Log the completion
if [ ! $DEBUG_MODE ]; then
	logger $0: Functions loaded from _functions
	fi

