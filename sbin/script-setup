#!/bin/bash
# /usr/local/sbin/script-setup

function f_get-config () {
    # $1: the config-name to be searched
    LANE_CONFIG_FILE_1="~/.lane/lane.conf"
    LANE_CONFIG_FILE_2="/etc/lane.conf"
    /usr/local/sbin/get-config "$1" "$LANE_CONFIG_FILE_1" "$LANE_CONFIG_FILE_2"
    }

function f_debug () {
    # $1: message to log
    if [ "$(f_get-config system.debug-mode)" == "true" ]; then
        logger $0: Debug: $1
        fi
    }

function f_debug_variable () {
    # $1: variable_name
    # $2: variable_value ("$variable_name")
    # Example: f_debug_variable "var" "$var"
    if [ "$(f_get-config system.debug-mode)" == "true" ]; then
        logger $0: Debug: $1 = $2
        fi
    }

function f_filter () {
    # $1: string being evaluated
    # $2: string of filter values separated by spaces allowing double quotes
    #    example: f_filter "CBS This Morning Saturday" "$(f_get-config filter.transcode-excluded)"
    # Result: echoes 1 (filter) or 0 (no filter)
    # SAMPLE USAGE:
    #   if $(f_filter "Today (1952)" "$(f_get-config filter.transcode-excluded)") ; then
    #       echo "Match found"
    #   else
    #       echo "No match found"
    #   fi

    STRING_BEING_EVALUATED=$1
    FILTER=$2
    MATCH=false

    # Ref: https://superuser.com/questions/1066455/how-to-split-a-string-with-quotes-like-command-arguments-in-bash
    eval "array=($FILTER)"
    for thisfilter in "${array[@]}"; do if [[ $STRING_BEING_EVALUATED == *"$thisfilter"* ]]; then MATCH=true ; fi; done
    echo $MATCH
	}

# function f_text_alert () {
#     # $1: the string value of the text message
#     TEXT_TARGETS=$(f_get-config text-alert-target-emails)
#     if [ "$(f_get-config text-alert-emails)" != "" ];
#    }

# If configured, make sure only root can run our script. Default = "false"
if [ "$(f_get-config script.$(basename $0).require-root)" == "true" ] && [[ $EUID -ne 0 ]]; then
        echo "Use sudo. $0 must be run as root." 1>&2
        exit 1
    fi

f_debug "script-setup started"

# If configured, log the start of script processing. Default = "true"
if [ "$(f_get-config script.$(basename $0).log-start)" != "true" ]; then logger "$0: start"; fi

# If configured, send a text message to note the start of script processing. Default = "false"
if [ "$(f_get-config script.$(basename $0).text-start)" == "true" ]; then f_text_alert "$0: start"; fi

# /etc/os-release defines a lot of environment variables 
# Sample:
#    NAME="Ubuntu"
#    VERSION="18.04.4 LTS (Bionic Beaver)"
#    ID=ubuntu
#    ID_LIKE=debian
#    PRETTY_NAME="Ubuntu 18.04.4 LTS"
#    VERSION_ID="18.04"
#    HOME_URL="https://www.ubuntu.com/"
#    SUPPORT_URL="https://help.ubuntu.com/"
#    BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
#    PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
#    VERSION_CODENAME=bionic
#    UBUNTU_CODENAME=bionic
source /etc/os-release

# Start timestamps
START_DATESTAMP=$(/bin/date '+%Y-%m-%d')
START_DAYSTAMP=$(/bin/date '+%d')
START_MONTHSTAMP=$(/bin/date '+%Y-%m')
START_TIMESTAMP=$(/bin/date)
START_WEEKDAYSTAMP=$(/bin/date '+%a')

# Process config file
LANE_CONFIG_FILE_1="~/.lane/lane.conf"
LANE_CONFIG_FILE_2="/etc/lane.conf"
if [ ! -z "$LANE_CONFIG[system.configs-defined]" ]; then
    unset LANE_CONFIG_FILE
    # Ref: https://linuxize.com/post/bash-check-if-file-exists/
    if [ -f "$LANE_CONFIG_FILE_1" ]; then
	    LANE_CONFIG_FILE="$LANE_CONFIG_FILE_1"
    else
	    if [ -f "$LANE_CONFIG_FILE_2" ]; then
		    LANE_CONFIG_FILE="$LANE_CONFIG_FILE_2"
        fi
    fi
    if [ ! -z "$LANE_CONFIG_FILE" ]; then
        OLDIFS=$IFS
        IFS=$'[ \t]*=[ \t]*'
        declare -A LANE_CONFIG
        while read -r NAME VALUE
        do	
	        if [ ! -z "$NAME" ] && [[ "$NAME" != "#"* ]]; then # Line is not blank and is not a comment
	 	        LANE_CONFIG[$NAME]="$VALUE"
	        fi
        done < "$LANE_CONFIG_FILE"
        IFS=$OLDIFS
        logger "$0: SUCCESS reading config file $LANE_CONFIG_FILE"
    else
        logger "$0: FAILED to read config file: None defined"
    fi
LANE_CONFIG["system.configs-defined"]=true
fi

# Information about Lane
LANE_CELL=${LANE_CONFIG[system.lane-cell]}
LANE_EMAIL=${LANE_CONFIG[system.lane-email]}
HOME_DIR=${LANE_CONFIG[system.home-me]}
HOME_ME=${LANE_CONFIG[system.home-me]}
HOME_RELATIVE=${LANE_CONFIG[system.home-me]}
USER_ME=${LANE_CONFIG[system.user-me]}
USER_NAME=${LANE_CONFIG[system.user-me]}

# General local and program variables
PROGRAM_DIRECTORY=$(dirname $0)
HOST_NAME=$(/bin/hostname -s)

# Are these still used at all?
LANE_SCRIPTS_PREFIX="lane-scripts"
UUID=$(uuidgen)

SBIN_DIR=${LANE_CONFIG[system.sbin-dir]}
SBIN_PARENT=${LANE_CONFIG[system.sbin-parent]}

TEMP_DATABASES="/tmp/$LANE_SCRIPTS_PREFIX-$UUID-databases.tmp"
TEMP_PASSWORD_INCLUDE="/tmp/passwords"
TEMP_INCLUDES="/tmp/$LANE_SCRIPTS_PREFIX-$UUID-includes.tmp"
TEMP_LOG="/tmp/$LANE_SCRIPTS_PREFIX-$UUID-log.tmp"
SCRIPTS_DIRECTORY=$SBIN_DIR
# As of 2020-06-05, $SCRIPTS_INCLUDES still us used by backup
SCRIPTS_INCLUDES=$SCRIPTS_DIRECTORY/include
IPV4_PUBLIC_ADDRESS=$(dig +short myip.opendns.com @resolver1.opendns.com)

# Host-specific deinitions. These need to come earlier because other definitions below use them.
case $HOST_NAME in
  red )
    ADDRESS=192.168.168.23
    ARCHIVE_DIRECTORY=/var/local/archives/$HOST_NAME
    USER_NAME=lhensley
    OFFSITE_SERVER=nuc01.local
    OFFSITE_PORT=22
    OFFSITE_PATH=/var/local/archives
    ;;
  nuc01 )
    ADDRESS=192.168.168.31
    ARCHIVE_DIRECTORY=/var/local/archives/$HOST_NAME
    USER_NAME=lhensley
    OFFSITE_SERVER=oz.lanehensley.org
    OFFSITE_PORT=10104
    OFFSITE_PATH=/usr/local/archives
    ;;
  oz )
    # ADDRESS=192.168.168.31
    USER_NAME=lhensley
    ARCHIVE_DIRECTORY=/usr/local/archives/$HOST_NAME
    OFFSITE_SERVER=lane.is-a-geek.org
    OFFSITE_PORT=10103
    OFFSITE_PATH=/var/local/archives
    ;;
esac

# Backup definitions
# THESE VARIABLES NEED TO BE DEFINED BEFORE THIS SECTION RUNS:
# $HOST_NAME $LANE_SCRIPTS_PREFIX $OFFSITE_PORT $START_DATESTAMP $START_WEEKDAYSTAMP $UUID
DIRECTORY_FROM=/
SOCKETS_TEMP_FILE="/tmp/$LANE_SCRIPTS_PREFIX-$UUID-socket-files.tmp"
ARCHIVE_TAR_FILE="$HOST_NAME-$START_DATESTAMP.gz"
ARCHIVE_TAR_FULL="$ARCHIVE_DIRECTORY/$ARCHIVE_TAR_FILE"
ARCHIVE_TAR_WEEKDAY_FILE="$HOST_NAME-weekday-$START_WEEKDAYSTAMP.gz"
ARCHIVE_TAR_FULL_WEEKDAY="$ARCHIVE_DIRECTORY/$ARCHIVE_TAR_WEEKDAY_FILE"
ARCHIVE_TAR_DAY_FILE="$HOST_NAME-day-$START_DAYSTAMP.gz"
ARCHIVE_TAR_FULL_DAY="$ARCHIVE_DIRECTORY/$ARCHIVE_TAR_DAY_FILE"
ARCHIVE_TAR_MONTH_FILE="$HOST_NAME-month-$START_MONTHSTAMP.gz"
ARCHIVE_TAR_FULL_MONTH="$ARCHIVE_DIRECTORY/$ARCHIVE_TAR_MONTH_FILE"
ARCHIVE_MYSQL_FILE="$HOST_NAME-$START_DATESTAMP.sql"
ARCHIVE_MYSQL_FULL="$ARCHIVE_DIRECTORY/$ARCHIVE_MYSQL_FILE"
ARCHIVE_MYSQL_LITURGY="$ARCHIVE_DIRECTORY/$HOST_NAME-liturgy.sql"
ARCHIVE_MYSQL_DB="$ARCHIVE_DIRECTORY/$HOST_NAME-$START_DATESTAMP-"
TAR="/bin/tar"
EXEC_BACKUP="$TAR --create --gzip --auto-compress --preserve-permissions"
EXEC_BACKUP="$EXEC_BACKUP --file=$ARCHIVE_TAR_FULL_WEEKDAY"
EXEC_BACKUP="$EXEC_BACKUP --exclude-backups"
EXEC_BACKUP="$EXEC_BACKUP --exclude-vcs --exclude-caches"
EXEC_BACKUP="$EXEC_BACKUP --totals"
# EXEC_BACKUP="$EXEC_BACKUP --verbose"
EXEC_BACKUP="$EXEC_BACKUP --exclude-from=$SOCKETS_TEMP_FILE"
EXEC_BACKUP="$EXEC_BACKUP /etc /home /root /usr/local/sbin /var/www"
# EXEC_BACKUP="$EXEC_BACKUP /var/local/archives/*.sql"
# NOTE: -t flag removed from next line 3/28/19. Generates error.
RSYNC_NO_DELETE="rsync -aopqrzE -e 'ssh -p $OFFSITE_PORT'"
RSYNC_SU="$RSYNC_NO_DELETE '$ARCHIVE_DIRECTORY'"
RSYNC_SU="$RSYNC_SU $OFFSITE_SERVER:$OFFSITE_PATH"
BACKUPLOG=$ARCHIVE_DIRECTORY/$HOST_NAME-backup.log

# Apache2
WEB_ROOTS="/var/www"
THIS_WEB_ROOT="$WEB_ROOTS/html"

# Passwords
LENGTH_OF_PASSWORDS=63
MAX_MYSQL_PASSWORD_LENGTH=32
EXCLUDED_PASSWORD_CHARACTERS=" \$\'\"\\\#\|\<\>\;\*\&\~\!\I\l\1\O\0\`\/\?"

# cron
TEMP_CRON="/tmp/cron-$UUID.tmp"

# ddclient
DDCLIENT_INTERVAL=7200

# Git
GIT=${LANE_CONFIG[system.git]}
GO=GIT=${LANE_CONFIG[system.git.go]}
GO_CONFIGS=${LANE_CONFIG[system.git.go.configs]}
GO_SBIN=${LANE_CONFIG[system.git.go.sbin]}
GO_SETUP=${LANE_CONFIG[system.git.go.setup]}

# MySQL
MYSQL_ADMIN_NAME="admin"
MYSQL_CLIENT_CERTS_DIR="$HOME_DIRECTORY/certs"
MYSQL_CONFIGS="/etc/mysql/conf.d"
MYSQL_DUMP_DIR=$HOME_DIR/mysql-dumps
MYSQL_SERVER_BIN_DIR="/var/lib/mysql"

# phpMyAdmin
PHPMYADMIN_DIR="/usr/share/phpmyadmin"

# ssh
SSHD_CONFIG="/etc/ssh/sshd_config"

# System User (Amazon AWS servers only)
USER_UBUNTU="ubuntu"

# Mail
MAILNAME=$HOST_NAME

# Basically, this section means look for *.sh in the "includes" directory and invoke them.
# find $SCRIPTS_INCLUDES -name "*.sh" -type f | while read INFILE
#   do
#     source "$INFILE"
#   done

# Set key file ownerships #############################################
/bin/chown root:root $MYSQL_CONFIGS/mysqldump.cnf >> /dev/null 2>&1
/bin/chown -R root:$USER_NAME $SCRIPTS_DIRECTORY >> /dev/null 2>&1
/bin/chown -R www-data:www-data $THIS_WEB_ROOT/ >> /dev/null 2>&1

# Set key file permissions ############################################
/bin/chmod 600 $MYSQL_CONFIGS/mysqldump.cnf >> /dev/null 2>&1
/bin/chmod -R 770 $SCRIPTS_DIRECTORY >> /dev/null 2>&1

# Echo variable values in debug mode
#
# if $debug_mode ; then
#   echo $(date)
#   env
#  fi

f_debug "script-setup ended"
