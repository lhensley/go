#!/bin/bash
# process_ts
# Usage: process_ts <input_file> <work_root_path> <store_root_path>
# No final / on either path. For system root, use ""

production_mode=true
debug_mode=false
# debug_mode=true
if $debug_mode ; then
  set -x
  fi

IN_FILE=$1
WORK_ROOT_PATH=$2
STORE_ROOT_PATH=$3

OUT_EXT="m4v"

WORK_ROOT_PATH_LENGTH=${#WORK_ROOT_PATH}

IN_FILE_LENGTH=${#IN_FILE}
IN_FILE_EXT="${IN_FILE##*.}"
IN_FILE_EXT_LENGTH="${#IN_FILE_EXT}"

RELATIVE_FILE_LENGTH=$[IN_FILE_LENGTH-WORK_ROOT_PATH_LENGTH-1]
RELATIVE_FILE=${IN_FILE: -$RELATIVE_FILE_LENGTH} # First remove WORK_ROOT_PATH
RELATIVE_FILE_NO_EXT_LENGTH=$[RELATIVE_FILE_LENGTH-IN_FILE_EXT_LENGTH-1] # Recalculate relative path length by removing extension length
RELATIVE_FILE_NO_EXT=${RELATIVE_FILE:0:RELATIVE_FILE_NO_EXT_LENGTH} # Then remove IN_FILE_EXT

OUT_FILE="$WORK_ROOT_PATH/$RELATIVE_FILE_NO_EXT.$OUT_EXT"
STORE_FILE="$STORE_ROOT_PATH/$RELATIVE_FILE_NO_EXT.$OUT_EXT"

HANDBRAKE="HandBrakeCLI"
PRESET="/home/lhensley/.HandBrake/Lane 1080p (BluRay).json"

# So here are useful variables defined ...
# $IN_FILE
# $OUT_FILE
# $STORE_FILE
# $WORK_ROOT_PATH
# $STORE_ROOT_PATH
# $RELATIVE_FILE

# Make sure only root can run our script
if [[ $EUID -ne 0 ]]; then
  echo "This script must be run as root."
  exit 1
fi

# Make sure $IN_FILE exists
if [ ! -f "$IN_FILE" ]; then
  logger "$0 no source file $IN_FILE"
  exit 1
  fi

# Make sure $IN_FILE is not in use
if [ -n "$(lsof "$IN_FILE" 2>/dev/null)" ]; then
    logger "$0: File in use and cannot be processed: $IN_FILE"
    exit 1
  fi

if [[ "$IN_FILE" != *"ABC World News Tonight"* ]] \
    && [[ "$IN_FILE" != *"BBC World News"* ]] \
    && [[ "$IN_FILE" != *"CBS Evening News"* ]] \
    && [[ "$IN_FILE" != *"CBS Morning News"* ]] \
    && [[ "$IN_FILE" != *"CBS This Morning"* ]] \
    && [[ "$IN_FILE" != *"CBS Weekend News"* ]] \
    && [[ "$IN_FILE" != *"Face the Nation"* ]] \
    && [[ "$IN_FILE" != *"Jimmy Kimmel Life"* ]] \
    && [[ "$IN_FILE" != *"KXAN News"* ]] \
    && [[ "$IN_FILE" != *"Meet the Press"* ]] \
    && [[ "$IN_FILE" != *"NBC Nightly News"* ]] \
    && [[ "$IN_FILE" != *"Sunday Today"* ]] \
    && [[ "$IN_FILE" != *"The Late Show"* ]] \
    && [[ "$IN_FILE" != *"The Tonight Show"* ]] \
    && [[ "$IN_FILE" != *"Today (195"* ]] \
    && [[ "$IN_FILE" != *".grab"* ]]; then

    sudo -u lhensley transcode >> /dev/null 2>&1 # Pick up ripped DVDs first, if any

    # Do the transcoding
    TIMESTART=$(currenttimeinseconds)
    logger "$HANDBRAKE starting transcoding of $IN_FILE"
    $HANDBRAKE --preset-import-file "$PRESET" \
        -i "$IN_FILE" -o "$OUT_FILE" >> /dev/null 2>&1
    exit_status=$?
    if [ $exit_status -ne 0 ]; then # If the transcoding failed ...
        logger "$HANDBRAKE transcoding FAILED for $IN_FILE"
        echo "Transcoding FAILED for $RELATIVE_FILE" | mail lanecell
        exit $exit_status
      else
        rm "$IN_FILE" >> /dev/null 2>&1 # Delete input file
        logger "$HANDBRAKE transcoding complete in $(timeformat $(( $(currenttimeinseconds) - TIMESTART ))) for $OUT_FILE"
      fi # End of check for transcoding failure

    move-one-file "$OUT_FILE" "$WORK_ROOT_PATH" "$STORE_ROOT_PATH"

    # Change permissions for Plex libraries
	find "$WORK_ROOT_PATH" -type d -print -exec chmod 775 {} \; >> /dev/null 2>&1
	find "$WORK_ROOT_PATH" -type f -print -exec chmod 664 {} \; >> /dev/null 2>&1
	find "$STORE_ROOT_PATH" -type d -print -exec chmod 775 {} \; >> /dev/null 2>&1
	find "$STORE_ROOT_PATH" -type f -print -exec chmod 664 {} \; >> /dev/null 2>&1
    chown -R plex:plex "$WORK_ROOT_PATH"
    chown -R plex:plex "$STORE_ROOT_PATH"

    exit $exit_status

fi