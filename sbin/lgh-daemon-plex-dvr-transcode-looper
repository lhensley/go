#!/bin/bash
# Looks for for files DVR recordings on a Plex server installation, and transcodes them. Pauses, then repeats forever.
# This script should be run as root from cron, executed at boot time.

# Include script setup file
	source script-setup
    source _functions-staging
	if [ ! $FUNCTIONS_ARE_DEFINED ];         then echo $0: Functions not defined. Aborting; logger $0: Functions not defined. Aborting;         exit 1; fi
	if [ ! $STAGING_FUNCTIONS_ARE_DEFINED ]; then echo $0: Staging functions not defined. Aborting; logger $0: Variables not defined. Aborting; exit 1; fi
	if [ ! $VARIABLES_ARE_DEFINED ];         then echo $0: Variables not defined. Aborting; logger $0: Variables not defined. Aborting;         exit 1; fi

    # set -x

    # Set the variables
    WAIT_AFTER_SOURCE_SCAN="1h"                         # How long to wait after looping through all source files
    SOURCE_FILE_NAME_PATTERN="$PLEX_FILE_NAME_PATTERN"  # For Plex DVR,                 this is "$PLEX_FILE_NAME_PATTERN"              (defined in _vars)
                                                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_FILE_NAME_PATTERN"           (defined in _vars)
                                                        # For Zoom meeting recordings,  this is "$ZOOM_FILE_NAME_PATTERN"              (defined in _vars)
    SOURCE_ROOT="$VIDEO_WORK_DIRECTORY"                 # For Plex DVR, this is "$VIDEO_WORK_DIRECTORY"                                (defined in _vars)
	  	     					                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_OUTPUT_DIRECTORY"            (defined in _vars)
	  	     					                        # For Zoom meeting recordings,  this is "$ZOOM_RAW_FILES"                      (defined in _vars)
    TARGET_ROOT="$VIDEO_STORE_DIRECTORY"                # For Plex DVR, this is "$VIDEO_STORE_DIRECTORY"                               (defined in _vars)
	  	     					                        # For DVDs ripped with MakeMKV, this is "$MAKEMKV_TRANSCODED_FILES_DIRECTORY"  (defined in _vars)
	  	     					                        # For Zoom meeting recordings,  this is "$ZOOM_TRANSCODED_FILES"               (defined in _vars)
    TARGET_FILE_EXTENSION=".m4v"                        # Normally this is ".m4v"                                                      (default defined in _vars)
    SET_PLEX_PERMISSIONS=true                           # Normally true only for Plex content files                                    (default defined in _vars)
    USE_TV_FILTERS=true                                 # Normally true only for Plex DVR files                                        (default defined in _vars)
    FLATTEN_TARGET_DIRECTORY=false                      # Normally used for Zoom meeting recordings and MAYBE Ripped DVDs (maybe; TBD) (default defined in _vars)
    PREPEND_PARENT_DIR_TO_BASENAME=false                # Normally used for Zoom meeting recordings                                    (default defined in _vars)
    APPEND_UUID_TO_TARGET_FILE=true                     # Normally used for Plex files so that multiple media files can be retained.   (default defined in _vars)
    USE_PARENT_DIR_AS_BASENAME=false                    # May be useful for ripped DVDs. TBD. Think about this first                   (default defined in _vars)

    
# Do the looping work
    while true; do
        # SOURCE_FILE is the newest file found, based on the sort shown below.
        #   The soft can be fooled by a "newer" directory structure name, because the sort is on the full pathname. 
        #   Oh well. Fix this if that becomes an issue.
	    # SOURCE_FILE="$(find -L $SOURCE_ROOT -type f -name $SOURCE_FILE_NAME_PATTERN -print | sort | tail -n 1)" # The soft and tail actually are not necessary here.
	    tv2=$(find -L "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" -print | tail -n 1)
        echo $tv2
        exit 1
	    SOURCE_FILE="$(find -L "$SOURCE_ROOT" -type f -name "$SOURCE_FILE_NAME_PATTERN" -print | tail -n 1)" # No sort. Just checking.
            # THEORY: Some files fail. Need a "next" option here, or the loop will get stuck on first-up failures.
        if [ -z "$SOURCE_FILE" ]; then
                f_log_and_echo "Sleeping $WAIT_AFTER_SOURCE_SCAN." true  # The TRUE part at the end means this sends pager notices.
                                                                         # Drop this when stable, and consider bumping up the interval.
                sleep "$WAIT_AFTER_SOURCE_SCAN"
            else
	            f_transcode_handbrake_source_video_file
                exit 1
            fi
        done

# Include script footer file
	f_debug_variable "script_footer" "${PATHNAME[script_footer]}"
	source "${PATHNAME[script_footer]}"

exit 0

